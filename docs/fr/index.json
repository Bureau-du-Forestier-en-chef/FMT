[{"authors":null,"categories":null,"content":"Qu\u0026rsquo;est-ce que FMT ? Dans sa forme la plus basique, FMT est une librairie open source de fonctions et d\u0026rsquo;objets que vous pouvez utiliser dans diff√©rents langages de programmation: C++, R ou Python.\nLes fonctions et les objets de FMT sont utilis√©s pour faire de la planification foresti√®re. La planification foresti√®re r√©pond √† la question de comment un paysage forestier doit √™tre trait√© afin de maximiser certains objectifs (par exemple, le rendement √©conomique), et sous certaines contraintes (par exemple, les objectifs √©cologiques et de conservation, la l√©gislation, les limites op√©rationnelles, etc.).\nConcr√®tement, FMT vous permet de :\n Lire les mod√®les de planification foresti√®re bas√©s sur le format de fichiers Woodstock (qui sont des mod√®les de programmation lin√©aire de type III r√©f√©renc√©s spatialement) Modifier et modifier ces mod√®les de planification foresti√®re R√©soudre ces mod√®les de planification foresti√®re (c\u0026rsquo;est-√†-dire g√©n√©rer un calendrier d\u0026rsquo;actions qui maximisent les objectifs et respectent les contraintes) Rendre les variables de peuplements et le calendrier optimis√© spatialement explicites (c\u0026rsquo;est-√†-dire cartographier les op√©rations foresti√®res)  √Ä quoi sert-il principalement ?  Lecture de mod√®les Woodstock Simulation de paysages forestiers Optimisation / R√©-optimisation de mod√®les Planification (en utilisant des √©v√©nements stochastiques) R√©solution des heuristiques d\u0026rsquo;agr√©gation Planification des blocs de r√©colte  Comment est-ce que √ßa marche techniquement ? Le code source des fonctions dans FMT est √©crit dans le langage C++.\nCependant, il est con√ßu pour √™tre compil√© dans diff√©rents formats de librairies de fonctions pouvant √™tre utilis√©s en langage Python et R.\ngraph TD;\r1--\u0026gt;2;\r1--\u0026gt;3;\r1--\u0026gt;4;\r1[\u0026quot;Interface de programmation (C++)\u0026quot;]\r2[\u0026quot;Python 2\u0026quot;]\r3[\u0026quot;Python 3\u0026quot;]\r4[\u0026quot;Cran R\u0026quot;]\r Pourquoi a-t-il √©t√© concu ? Le projet FMT a d√©but√© en 2017, au Bureau du forestier en chef (BFEC) du Qu√©bec.\n√âtant donn√© que le BFEC utilisait des mod√®les Woodstock tous les jours, il √©tait n√©cessaire d\u0026rsquo;avoir des scripts r√©plicables permettant aux analystes de lire et d\u0026rsquo;√©diter automatiquement les fichiers de mod√®les Woodstock sans utiliser l\u0026rsquo;interface graphique de Woodstock √† chaque fois.\nEn 2018, le BFEC a commenc√© √† s\u0026rsquo;int√©resser √† un outil permettant de quantifier les stocks de carbone dans les for√™ts. L\u0026rsquo;outil choisi (GCBM) fait des estimations pr√©cises des stocks et des flux de carbone, mais il a besoin d\u0026rsquo;informations sur l\u0026rsquo;endroit et le moment des coupes dans le paysage forestier, selon diff√©rents sc√©narios d\u0026rsquo;am√©nagement forestier.\nPour cette raison, un mod√®le √©tait n√©cessaire pour transformer les informations r√©f√©renc√©es spatialement des mod√®les de Woodstock (qui regroupent toutes les for√™ts du m√™me type dans le paysage) en informations spatialement explicites (qui se trouvent √† un emplacement pr√©cis sur une carte).\nDe 2019 √† aujourd\u0026rsquo;hui, de nombreuses fonctionnalit√©s ont √©t√© impl√©ment√©es pour am√©liorer les performances de FMT, et sa capacit√© √† faire de la replanification.\nQuels est le futur de FMT ?  Une interface utilisateur.ice pour certaines fonctions utiles aux analystes du BFEC, et pour son int√©gration avec GCBM Optimisation spatialement explicite (actuellement, l\u0026rsquo;optimisation se fait au niveau spatialement r√©f√©renc√©, et les r√©sultats sont ensuite rendus spatialement explicites avec des heuristiques) De meilleures sorties (outputs) pour faciliter son int√©gration avec d\u0026rsquo;autres mod√®les ou scripts   Maintenant que vous en savez tant sur FMT, vous n\u0026rsquo;aurez aucun mal √† comprendre comment il fonctionne et comment l\u0026rsquo;utiliser.\n FMT utilise une structure de mod√®le et des entr√©es tr√®s similaires au logiciel Woodstock de Remsoft.\nSi vous ne connaissez rien aux mod√®les Woodstock, vous devriez prendre le temps de lire √† leur propos avant de lire cette documentation. Vous vous sentirez un peu perdu si vous ne le faites pas.\n  Pr√™t.e √† commencer ?\n üìñ Commencer √† lire   ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"fr","lastmod":1536451200,"objectID":"04db5c02e6f257acc19ec89db5919756","permalink":"https://bureau-du-forestier-en-chef.github.io/FMT/fr/docs/basics/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/FMT/fr/docs/basics/","section":"docs","summary":"Comprendre ce que FMT est, et ce qu'il fait.","tags":null,"title":"Les bases de FMT","type":"book"},{"authors":null,"categories":null,"content":"FMT est un programme qui n√©cessite d\u0026rsquo;√™tre compil√© sur votre ordinateur pour pouvoir √™tre ex√©cut√©.\nNe vous inqui√©tez pas ; ce n\u0026rsquo;est pas aussi complexe qu\u0026rsquo;il n\u0026rsquo;y para√Æt !\nQu\u0026rsquo;est-ce que la compilation ? La compilation est une √©tape au cours de laquelle votre ordinateur va transformer le code source (qui sont des fichiers que vous, en tant qu\u0026rsquo;humain.e, pouvez lire) du programme en un ensemble de binaires (binaries) (qui sont des fichiers que votre ordinateur peut lire).\n Vous utilisez des binaries tous les jours, sans m√™me y penser. Par exemple, un fichier .exe sous Windows est un binarie. Si vous l\u0026rsquo;ouvrez avec le bloc-notes de Windows, vous ne serez pas en mesure de comprendre son contenu, mais votre ordinateur le peut.   Que faut-il pour compiler ? Pour compiler FMT, votre ordinateur aura besoin de :\n Le code source de FMT Toutes les biblioth√®ques de fonctions utilis√©es par FMT Un compilateur  La documentation vous guidera pour toutes ces √©tapes.\n Tout pr√©parer prend environ une demi-heure, mais le t√©l√©chargement et la compilation prennent environ 6 heures (mais vous n\u0026rsquo;avez rien √† faire pendant que votre ordinateur s\u0026rsquo;en occupe).    Actuellement, cette documentation pour la compilation de FMT ne couvre que l\u0026rsquo;installation de FMT pour Windows 8-10, et pour une utilisation sous Python.\nSi vous √™tes un utilisateur de Mac ou de Linux, ou si vous voulez utiliser FMT sous R, veuillez nous pr√©venir dans la section issue section of the FMT repository.\n  Pr√™t.e √† commencer ?\n üíæ Commencer l\u0026rsquo;installation   ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"fr","lastmod":1536451200,"objectID":"cb3f7061761e7263b0c7801f991613a2","permalink":"https://bureau-du-forestier-en-chef.github.io/FMT/fr/docs/download_install/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/FMT/fr/docs/download_install/","section":"docs","summary":"D√©couvrez comment t√©l√©charger et installer FMT sur votre ordinateur.","tags":null,"title":"T√©l√©chargement et installation","type":"book"},{"authors":null,"categories":null,"content":"Bienvenue dans la documentation de FMT !\n Avant de commencer √† lire, sachez que vous pouvez modifier l\u0026rsquo;apparence de la documentation (th√®me clair ou sombre) en utilisant la petite ic√¥ne de lune ou de soleil dans le coin sup√©rieur droit de l\u0026rsquo;√©cran.    FMT utilise une structure de mod√®le et des entr√©es tr√®s similaires au logiciel Woodstock de Remsoft.\nSi vous ne connaissez rien aux mod√®les Woodstock, vous devriez prendre le temps de lire √† leur propos avant de lire cette documentation. Vous vous sentirez un peu perdu si vous ne le faites pas.\n  Si vous voulez mieux comprendre ce qu\u0026rsquo;est FMT et ce qu\u0026rsquo;il fait, vous pouvez commencer par les bases :\n ‚ú® D√©couvrir les bases de FMT   Si vous souhaitez installer FMT, consultez les instructions d\u0026rsquo;installation :\n üíæ T√©l√©charger et installer FMT   Sinon, vous pouvez utiliser la barre de recherche ou la table des mati√®res √† votre gauche pour trouver ce que vous cherchez.\nBonne lecture !\n","date":1557010800,"expirydate":-62135596800,"kind":"section","lang":"fr","lastmod":1557010800,"objectID":"4cdd37113783e47641dd300543c94e1b","permalink":"https://bureau-du-forestier-en-chef.github.io/FMT/fr/docs/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/FMT/fr/docs/","section":"docs","summary":"Bienvenue dans la documentation de FMT !\n Avant de commencer √† lire, sachez que vous pouvez modifier l\u0026rsquo;apparence de la documentation (th√®me clair ou sombre) en utilisant la petite ic√¥ne de lune ou de soleil dans le coin sup√©rieur droit de l\u0026rsquo;√©cran.","tags":null,"title":"Documentation de FMT","type":"book"},{"authors":null,"categories":null,"content":"Que sont les objets ? FMT est fabriqu√© avec une structure particuli√®re appel√©e Programmation orient√©e objet (POO). Si vous n\u0026rsquo;en avez jamais entendu parler, en voici un r√©sum√© tr√®s rapide pour mieux comprendre comment utiliser FMT.\nDans l\u0026rsquo;approche OOP, le programme utilise diff√©rents \u0026ldquo;objets\u0026rdquo; qui ont une certaine \u0026ldquo;classe\u0026rdquo; et qui peuvent avoir diff√©rentes \u0026ldquo;fonctions\u0026rdquo;.\nVous connaissez et utilisez peut-√™tre d√©j√† des fonctions dans des logiciels tels que \u0026ldquo;R\u0026rdquo;. Par exemple, dans R, plot() est une fonction.\nVous pourriez √©galement √™tre habitu√©.e √† certains objets et classes dans le logiciel que vous utilisez. Par exemple, dans R, data\u0026lt;-read.csv (donn√©es.csv) met le contenu des donn√©es.fichier csv dans l\u0026rsquo;objet data, qui a la classe data frame.\nMaintenant, imaginez que chaque fonction que vous utilisez est associ√©e √† un objet d\u0026rsquo;une classe particuli√®re. Par exemple, une classe chien aurait la fonction abboyer_sur(). Si nous avons une classe nomm√©e chat, nous pourrions alors :\n Cr√©er un nouvel objet chien de la classe chien : pluto = chien(nom = Pluto, age = 8) Cr√©er un nouvel objet chat √† partir de la classe chat : felix = chat(nom = Felix, age = 2) Faire aboyer le chien sur le chat: pluto.abboyer_sur(felix)  √Ä son tour, l\u0026rsquo;objet peut avoir des \u0026ldquo;propri√©t√©s\u0026rdquo;, qui sont exactement ce √† quoi cela ressemble. Par exemple, disons que notre classe chat a trois propri√©t√©s : nom (qui peut √™tre une cha√Æne de caract√®res), age (qui peut √™tre un nombre) et effray√© (qui est un bool√©en, true ou false).\nDans notre exemple pr√©c√©dent, avant d\u0026rsquo;utiliser pluto.abboyer_sur(felix), la propri√©t√© felix.peur pouvait √™tre false. Mais maintenant que nous avons utilis√© pluto.abboyer_sur(felix), felix.effray√© s\u0026rsquo;est surement chang√© en true.\nEnfin, une classe parent en programmation orient√©e objet signifie que la classe enfant h√©ritera automatiquement de toutes les fonctions et propri√©t√©s de la fonction parent.\nPar exemple, supposons que nous ayons une classe parent animal dont d√©rivent les classes chien et chat. Si la classe animal a une fonction respiration (animal.respiration()), alors les classes chien et chat √©tant ses classes enfant, elles auront automatiquement cette fonction (chien.respiration()) et chat.respiration()).\nLa programmation orient√©e objet est une fa√ßon particuli√®re de programmer, int√©gr√©e dans le langage de programmation que vous utilisez, qui pr√©sente de multiples avantages. L\u0026rsquo;un d\u0026rsquo;eux est de rendre les choses plus faciles √† repr√©senter.\nEn bref : FMT utilise la programmation orient√©e objet, ce qui fait de tout un objet avec des fonctions particuli√®res. Les fonctions et propri√©t√©s d\u0026rsquo;un objet sont d√©finies par sa classe.\nPour apprendre √† utiliser FMT, vous apprendrez quelles sont ses classes principales, afin que vous puissiez cr√©er les objets dont vous avez besoin et les faire interagir pour faire les choses que vous voulez faire. En effet, que ce soit en Python, R ou C ++, utiliser FMT signifie utiliser ses diff√©rents objets.\nLes namespaces de FMT Les diff√©rentes classes d\u0026rsquo;objets dans FMT sont regroup√©es en espaces de noms (namespaces), qui sont simplement les diff√©rentes sections de ses fichiers.\nDans FMT, les diff√©rents espaces de noms sont :\n Parser : Contient des classes utilis√©es pour lire ou √©diter les fichiers des mod√®les au format Woodstock Mod√®les: Contient des classes utilis√©es pour manipuler et r√©soudre les mod√®les Spatial: Contient des classes utilis√©es pour pour travailler sur des donn√©es spatialement explicites Heuristique : Contient les heuristiques utilis√©es pour agr√©ger spatialement les blocs de coupe et les planifier dans le temps Version: Contient des informations sur la version actuelle de FMT, et les fonctions qu\u0026rsquo;elle contient (ce qui d√©pend de la fa√ßon dont il a √©t√© compil√©e)   Si vous regardez l\u0026rsquo;[importation de FMT dans Python](../../download_install/importing_in_python /), vous verrez que nous importons les principaux espaces de noms dont vous aurez besoin en Python.   Classes importantes de l\u0026rsquo;espace de noms Parser L\u0026rsquo;espace de noms Parser contient deux classes importantes pour la lecture des mod√®les :\n FMTareaparser : Permet la lecture et l\u0026rsquo;√©criture des fichiers raster et vectoriels utilis√©s dans les op√©rations spatiales de FMT  Certaines de ses fonctions vous permettent de transformer des donn√©es entre le format vectoriel et le format raster.   FMTmodelparser : Permet de lire les fichiers d\u0026rsquo;un mod√®le Woodstock avec la fonction read project(), ou de l\u0026rsquo;enregistrer avec la fonction write() apr√®s l\u0026rsquo;avoir modifi√©.  La classe utilise √©galement d\u0026rsquo;autres classes faites pour lire les fichiers Woodstock.    La classe FMTmodel La classe FMTmodel est la base de FMT.\nElle contient des informations provenant des fichiers des mod√®les au format Woodstock. Cela peut √™tre vu en regardant les propri√©t√©s du FMTmodel :\n  Cependant, ces attributs sont \u0026ldquo;prot√©g√©s\u0026rdquo; afin qu\u0026rsquo;ils ne soient pas modifi√©s de mani√®re incorrecte. Si vous souhaitez les lire lors de l\u0026rsquo;utilisation de FMT, vous devrez utiliser les fonctions getter qui les obtiendront pour vous :\n  De plus, vous pouvez les modifier de la bonne mani√®re en utilisant les fonctions setter. Cela vous permet d\u0026rsquo;√©diter diff√©rentes parties du mod√®le.\n  En fin de compte, le FMTModel est ce que nous appelons une classe parent pour toutes les diff√©rentes classes de mod√®les utilis√©es par FMT, telles que FMTlpmodel (mod√®le de programmation lin√©aire) et FMTsesmodel (mod√®le spatialement explicite) selon le diagramme suivant :\nclassDiagram\rFMTobject \u0026lt;|-- FMTmodel\rFMTmodel \u0026lt;|-- FMTsamodel\rFMTmodel \u0026lt;|-- FMTsesmodel\rFMTmodel \u0026lt;|-- FMTsrmodel\rFMTsrmodel \u0026lt;|-- FMTlpmodel\rFMTsrmodel \u0026lt;|-- FMTnssmodel\r Observez que toutes ces classes h√©ritent finalement de la classe FMTobject. C\u0026rsquo;est le cas pour chaque objet de FMT, car FMTobject contient des fonctions et des propri√©t√©s utiles pour d√©boguer FMT.\nLes mod√®les FMTnssmodel et FMTlpmodel sont des mod√®les r√©f√©renc√©s spatialement. Le FMTlpmodel est utilis√© pour l\u0026rsquo;optimisation, tandis que FMTnssmodel est utilis√© pour la simulation.\nEn contraste, les mod√®les FMTsesmodel et FMTsamodel sont des mod√®les spatialement explicites. De la m√™me mani√®re, FMTsamodel est utilis√© pour l\u0026rsquo;optimisation, tandis que FMTsesmodel est utilis√© pour la simulation.\nNous examinerons de plus pr√®s les diff√©rents types de mod√®les plus tard. Pour l\u0026rsquo;instant, nous n\u0026rsquo;utiliserons que le mod√®le le plus simple qui correspond le plus √† une structure de mod√®le de Woodstock, le FMTlpmodel.\nLire un simple FMTlpmodel Voici un exemple qui permet de lire un mod√®le de programmation lin√©aire (au format Woodstock) avec FMT.\nEn R, le code pour correspondant serait :\nlibrary(FMT) # Charge FMT dans R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # V√©rifie si FMT a √©t√© compil√© avec OSI en cr√©ant un nouvel objet FMTversion, et en utilisant la fonction hasfeature().\r{\r# Cr√©er un objet parser pour lire les fichiers du mod√®le\rnewmodelparser \u0026lt;- new(FMTmodelparser)\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\rmodel_scenario_lp \u0026lt;- modelslist[[1]]\r# On r√©cup√®re le nom du mod√®le\rprint(model_scen_lp$getname())\r} else { # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\r Dans Python, le m√™me code aurait la forme suivante :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;): # V√©rifie si FMT a √©t√© compil√© avec OSI en utilisant la fonction hasfeature() de la classe FMTversion.\r# Cr√©er un objet parser pour lire les fichiers du mod√®le\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist = newmodelparser.readproject(path, scenarios)\rmodel_scen_lp = modelslist[0]\r# On r√©cup√®re le nom du mod√®le\rprint(model_scen_lp.getname())\relse:\r# Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r Que ce soit dans le terminal de R ou de Python, les codes pr√©c√©dents devraient affichier la m√™me chose :\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\r[1] \u0026quot;LP\u0026quot;\r Comme on peut le voir, FMT indique qu\u0026rsquo;il a lu le sc√©nario \u0026ldquo;LP\u0026rdquo;, et il affiche son nom.\nL\u0026rsquo;espace de noms Core. L\u0026rsquo;espace de nom Core contient les √©l√©ments utilis√©s par FMT \u0026ldquo;sous le capot\u0026rdquo; pour faire fonctionner l\u0026rsquo;objet FMTModel.\nPar exemple, il contient les objets :\n FMTaction : Classe qui d√©finit l\u0026rsquo;op√©rabilit√© de plusieurs strates pour une perturbation donn√©e. FMTtransition : Classe qui d√©finit les transitions de strates multiples pour une perturbation donn√©e. FMTyields : Classe qui d√©finit les valeurs de croissance et de rendement pour chaque strate. FMToutputs : Classe qui d√©finit les sorties dans le mod√®le (inventaire ou action), mais pas les sorties du mod√®le (par exemple, les fichiers de sortie ou autres). FMTconstraints : Classe qui d√©finit les contraintes globales et l\u0026rsquo;objectif du mod√®le (par exemple, la variable √† optimiser).  Ces diff√©rents objets peuvent √™tre appel√©s depuis un objet FMTmodel avec les diff√©rentes fonctions getter.\nPar exemple, pour voir la liste des objets FMTaction associ√©s √† un FMTmodel particulier, vous pouvez utiliser la fonction FMTModel.getactions() (ou FMTModel$getactions() en R), et utiliser une boucle for pour afficher toutes les actions dans le mod√®le. Les actions affich√©es de cette mani√®re correspondront aux actions pr√©sentes dans le fichier .act des fichiers Woodstock pour le mod√®le.\nVoici un exemple qui affiche les actions et les transitions d\u0026rsquo;un FMTmodel en code R :\nlibrary(FMT) # Charge FMT dans R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # V√©rifie si FMT a √©t√© compil√© avec OSI en cr√©ant un nouvel objet FMTversion, et en utilisant la fonction hasfeature().\r{\r# Cr√©er un objet parser pour lire les fichiers du mod√®le\rnewmodelparser \u0026lt;- new(FMTmodelparser)\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\rmodel \u0026lt;- modelslist[[1]]\r# R√©cup√®re le actions du mod√®le et les affiche\rprint(\u0026quot;***** Here is the name of the actions\u0026quot;)\rfor (action in model$getactions())\r{\rprint(action$getname())\r}\r# On fait de m√™me pour les transitions\rprint(\u0026quot;***** Here is the name of the transitions\u0026quot;)\rfor (transition in model$gettransitions())\r{\r# On concat√©ne l'entr√©e pour la transition afin de la rendre plus lisible dans le terminal\rcat(transition$str())\r}\r} else { # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\r Ce code en R affichera le texte suivant dans le terminal :\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\r[1] \u0026quot;***** Here is the name of the actions\u0026quot;\r[1] \u0026quot;CLEARCUT\u0026quot;\r[1] \u0026quot;ACARIBOU\u0026quot;\r[1] \u0026quot;PLANTATION\u0026quot;\r[1] \u0026quot;AFIRE\u0026quot;\r[1] \u0026quot;ARECUP\u0026quot;\r[1] \u0026quot;_DEATH\u0026quot;\r[1] \u0026quot;***** Here is the name of the transitions\u0026quot;\r*CASE CLEARCUT\r*SOURCE ? ? ?\r*TARGET ? ? ? 100.000000\r*CASE ACARIBOU\r*SOURCE ? ? ?\r*TARGET ? ? ? 100.000000 _LOCK 1\r*CASE PLANTATION\r*SOURCE ? ? ?\r*TARGET ? STAND1 ? 100.000000\r*CASE AFIRE\r*SOURCE ? ? ?\r*TARGET ? FIRE ? 100.000000\r*CASE ARECUP\r*SOURCE ? FIRE ?\r*TARGET ? STAND1 ? 100.000000\r*CASE _DEATH\r*SOURCE ? ? ?\r*TARGET ? ? ? 100.000000\r L\u0026rsquo;√©quivalent en Python serait :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Cr√©er un objet parser pour lire les fichiers du mod√®le\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist = newmodelparser.readproject(path, scenarios)\rmodel = modelslist[0]\r# R√©cup√®re le actions du mod√®le et les affiche\rprint(\u0026quot;***** Here is the name of the actions\u0026quot;)\rfor action in model.getactions():\rprint(action)\r# On fait de m√™me pour les transitions\rprint(\u0026quot;***** Here is the name of the transitions\u0026quot;)\rfor transition in model.gettransitions():\rprint(transition.getname())\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r Ce qui donnera le texte suivant dans le terminal Python. Notez que si les sorties entre R et Python devraient g√©n√©ralement √™tre les m√™mes, il existe parfois de petites diff√©rences. Ici, la version Python affichera plus d\u0026rsquo;informations sur les actions, et juste le nom des transitions par rapport √† R ; ceci est d√ª aux particularit√©s des deux langages.\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\r***** Here is the name of the actions\r*ACTION CLEARCUT Y\r*OPERABLE COUPETOTALE\r? ? ? TOTALVOLUME \u0026gt;= 100.000000\r*ACTION ACARIBOU N\r*OPERABLE ACARIBOU\rUC ? ? _AGE \u0026gt;= 8\r*ACTION PLANTATION Y _LOCKEXEMPT\r*OPERABLE PLANTATION\r? ? ? _AGE \u0026gt;= 1 AND _AGE \u0026lt;= 3\r*ACTION ARECUP Y\r*OPERABLE AFIRE\r? PROD ? _AGE \u0026gt;= 1\r*ACTION ARECUP Y\r*OPERABLE ARECUP\r? FEU ? _AGE = 0\r*ACTION _DEATH Y _LOCKEXEMPT\r*OPERABLE _DEATH\r? ? ? _AGE \u0026gt;= 80\r***** Here is the name of the transitions\rCLEARCUT\rACARIBOU\rPLANTATION\rAFIRE\rARECUP\r_DEATH\r Comparer des √©l√©ments dans FMT Une op√©ration courante √† faire dans vos scripts sera de comparer des √©l√©ments : par exemple, comparer le nom d\u0026rsquo;un objet FMTaction avec le nom de l\u0026rsquo;action que vous voulez s√©lectionner, etc.\nDans de tels cas, rappelez-vous que toutes les cha√Ænes de caract√®res lues par FMT sont automatiquement mises en majuscules. Par cons√©quent, si vous voulez comparer le nom des √©l√©ments dans FMT, assurez-vous que les lettres sont en majuscules.\nPar exemple, si vous avez une action nomm√©e Clearcut ou clearcut que vous voulez s√©lectionner, vous devrez comparer le nom des FMTactions des mod√®les avec le mot CLEARCUT, tout en majuscules.\nConversion des erreurs en avertissements Toutes les classes FMT h√©ritent de la classe FMTobject, et partagent donc les m√™mes objets FMTexceptionhandler et FMTlogger.\nSi l\u0026rsquo;utilisateur veut ignorer certaines erreurs, il peut utiliser la fonction seterrorstowarnings de n\u0026rsquo;importe quelle classe FMT et passer un vecteur d\u0026rsquo;erreurs que le gestionnaire d\u0026rsquo;erreurs doit consid√©rer comme des avertissements. Cette fonction est hazardeuse et peux mener a des erreurs. Il est recommand√© d\u0026rsquo;investiguer les messages d\u0026rsquo;erreur de FMT et de corriger les mod√®les cons√©quement.\n Maintenant que vous savez tout sur la structure de FMT et ses √©l√©ments de base, nous allons voir comment faire de l\u0026rsquo;optimisation √† r√©f√©rence spatiale avec elle, qui est l\u0026rsquo;une des principales fonctions de FMT.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"28124c8adfcb86aa5fb7c74a49d23b63","permalink":"https://bureau-du-forestier-en-chef.github.io/FMT/fr/docs/basics/objects_parsing_interrogation/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMT/fr/docs/basics/objects_parsing_interrogation/","section":"docs","summary":"Que sont les objets ? FMT est fabriqu√© avec une structure particuli√®re appel√©e Programmation orient√©e objet (POO). Si vous n\u0026rsquo;en avez jamais entendu parler, en voici un r√©sum√© tr√®s rapide pour mieux comprendre comment utiliser FMT.","tags":null,"title":"Objets, lecture et interrogation de mod√®les","type":"book"},{"authors":null,"categories":null,"content":" T√©l√©charger et installer Visual Studio Community   Lors de l\u0026rsquo;installation de Visual Studio Community, n\u0026rsquo;oubliez pas d\u0026rsquo;indiquer pendant l\u0026rsquo;installation que vous voulez que l\u0026rsquo;outil de compilation Cmake soit install√©.    Visual Studio Community est la version gratuite du logiciel Visual Studio de Microsoft. Nous l\u0026rsquo;utiliserons plus tard pour compiler FMT, car il est install√© avec un compilateur compatible avec Windows.   T√©l√©chargez et installez Mosek   Mosek est un solveur pour les probl√®mes de programmation lin√©aire, qui est exactement le type de probl√®mes que traite FMT. Cependant, FMT peut fonctionner avec diff√©rents autres solveurs, libres ou non.   Cr√©ez un dossier FMT-Installation dans votre ordinateur. Assurez-vous qu\u0026rsquo;il n\u0026rsquo;y a pas d\u0026rsquo;espaces ou d\u0026rsquo;accents dans le chemin menant au dossier.   Les espaces et les accents dans le chemin peuvent causer des erreurs avec diff√©rents programmes et diff√©rentes √©tapes de la compilation. C\u0026rsquo;est embettant, mais c\u0026rsquo;est comme √ßa !   Ouvrez une invite de commande, et utilisez la commande cd pour naviguer dans le dossier FMT-Installation.   Pour ouvrir l\u0026rsquo;invite de commande sous Windows 10, appuyez simplement sur la touche , tapez cmd, puis appuyez sur Entr√©e.\nLa commande cd est utilis√©e pour changer le dossier √† l\u0026rsquo;int√©rieur duquel l\u0026rsquo;invite de commande est pr√™te √† agir.\nTapez cd .. pour aller dans le dossier parent de celui dans lequel vous √™tes, et cd dossier pour aller dans un dossier.\n  ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"b66c69f45a1514d17932505c1f981ea0","permalink":"https://bureau-du-forestier-en-chef.github.io/FMT/fr/docs/download_install/prerequisits/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMT/fr/docs/download_install/prerequisits/","section":"docs","summary":"T√©l√©charger et installer Visual Studio Community   Lors de l\u0026rsquo;installation de Visual Studio Community, n\u0026rsquo;oubliez pas d\u0026rsquo;indiquer pendant l\u0026rsquo;installation que vous voulez que l\u0026rsquo;outil de compilation Cmake soit install√©.","tags":null,"title":"Pr√©requis","type":"book"},{"authors":null,"categories":null,"content":"Dans la section pr√©c√©dente, nous avons vu comment lire un mod√®le Woodstock et le charger dans un objet FMTlpmodel.\nFMTlpmodel vous permettra de r√©soudre un mod√®le de programmation lin√©aire √† spatialement r√©f√©renc√©, ce qui vous donnera un calendrier (schedule) optimis√© d\u0026rsquo;op√©rations foresti√®res en fonction d\u0026rsquo;un objectif et d\u0026rsquo;un ensemble de contraintes.\nIci, nous allons voir comment r√©aliser cette optimisation en pratique.\nUn petit rappel sur la signification de \u0026ldquo;spatialement r√©f√©renc√©\u0026rdquo;. On peut distinguer 3 fa√ßons de prendre en compte l\u0026rsquo;espace dans un mod√®le :\n Dans un mod√®le non spatial ou mod√®le spatialement implicite, les entit√©s (par exemple, les for√™ts, les animaux, les agents, etc.) ne sont pas directement associ√©es √† une position dans l\u0026rsquo;espace, mais la relation entre elles dans le mod√®le peut impliquer que seules certaines d\u0026rsquo;entre elles interagissent entre elles de mani√®re √† mimer une disposition spatiale. Dans un mod√®le spatialement r√©f√©renc√©, les entit√©s sont associ√©es √† des r√©gions de l\u0026rsquo;espace, mais pas √† une position pr√©cise dans ces r√©gions ; ces r√©gions peuvent √™tre non-continues. Les mod√®les de Woodstock sont par nature spatialement r√©f√©renc√©s, car ils consid√®rent des strates qui correspondent √† des for√™ts de m√™me composition et de m√™me √¢ge, qui peuvent √™tre dispers√©es en de nombreux endroits du paysage. Dans un mod√®le spatialement explicite, les entit√©s sont associ√©es √† des coordonn√©es pr√©cises dans l\u0026rsquo;espace, comme dans les pixels d\u0026rsquo;une carte matricielle.  La structure du FMTlpmodel : FMTgraph et FMTdevelopment FMTlpmodel, FMTgraph et FMTdevelopment sont trois classes qui sont importantes pour comprendre comment un mod√®le de programmation lin√©aire est repr√©sent√© dans FMT, et comment le r√©soudre.\nFMTlpmodel est un mod√®le de planification foresti√®re √† programmation lin√©aire de type III, qui est spatialement r√©f√©renc√©.\nIl peut r√©soudre un mod√®le de planification foresti√®re de type III, et obtenir un calendrier de r√©colte optimal en utilisant les contraintes et les objectifs d√©finis par l\u0026rsquo;utilisateur.\n La notion de type I, II et III des mod√®les de planification foresti√®re correspond √† une taxonomie particuli√®re relative √† leur structure math√©matique, et √† la mani√®re dont ils peuvent √™tre r√©solus. Les mod√®les de planification foresti√®re de type III sont actuellement les plus avanc√©s, et peuvent √™tre r√©solus pour de grands paysages avec beaucoup de surface foresti√®re. Vous pouvez en apprendre davantage √† leur sujet en lisant cet article.   Le FMTlpmodel contient un objet appel√© FMTgraph, qui contient le graphe du mod√®le. Le graphe est un ensemble de noeuds reli√©s entre eux par des liens. Chaque noeud correspond √† un √©tat possible pour une strate particuli√®re (qui sont des groupes de peuplements forestiers r√©f√©renc√©s dans l\u0026rsquo;espace avec les m√™mes caract√©ristiques), et chaque lien repr√©sente une fa√ßon particuli√®re dont elle peut √©voluer vers un autre √©tat dans la m√™me p√©riode de temps et entre les p√©riodes.\nVoici une repr√©sentation visuelle d\u0026rsquo;un FMTgraph simple, dans lequel une strate particuli√®re peut √©voluer √† partir de diff√©rents √©tats (objets FMTdevelopment) avec diff√©rentes transitions caus√©es par diff√©rentes actions √† travers la m√™me p√©riode de temps. L\u0026rsquo;√©volution des strates se fait entre les p√©riodes et consiste √† augmenter l\u0026rsquo;√¢ge de ces derni√®res de 1 :\n  Un FMTdevelopment est une classe importante de FMT. Elle repr√©sente une strate particuli√®re, c\u0026rsquo;est-√†-dire un peuplement forestier particulier qui a une composition et un √¢ge donn√©s, et qui existe √† une p√©riode donn√©e.\nPar cons√©quent, l\u0026rsquo;objet FMTdevelopment est associ√© √† un objet FMTmask, qui d√©crit l\u0026rsquo;ensemble des attributs (FMTtheme) qui d√©finit le FMTdevelopment. Ceci est illustr√© sur le visuel suivant :\n  FMTdevelopment est la classe parente de deux classes, FMTactualdevelopment et FMTfuturdevelopment. Un FMTactualdevelopment repr√©sente toujours une strate en d√©but d\u0026rsquo;horizon de planification et contient donc l\u0026rsquo;information de la superficie de la strate. Les FMTfuturdevelopment sont les futurs possibles et donc aucune superficie ne leur est attribu√©e au d√©part. C\u0026rsquo;est le r√©sultat de l\u0026rsquo;optimisation qui nous informe sur la r√©partitions future des superficies au travers du FMTgraph.\n  Voici ici quelques fonctions de la classe FMTdevelopment qui peuvent √™tre importantes pour manipuler le mod√®le √† diff√©rente fins :\n FMTdevelopment.grow() peut faire grandir le peuplement pour voir ce qu\u0026rsquo;il va devenir. Renvoie un FMTfuturdevelopment identique au FMTdevelopment √† partir duquel la fonction est appel√©e mais avec un √¢ge augment√© de 1 FMTdevelopment.operable() peut tester si une action donn√©e peut √™tre appliqu√©e √† ce d√©veloppement, sur la base d\u0026rsquo;une section de yield(une variable particuli√®re, par exemple) FMTdevelopment.operate() peut faire diff√©rentes actions sur la strate, et retourner un vecteur de FMTdevelopmentpath.  Maintenant, nous pouvons regarder comment construire le \u0026ldquo;graphe complet\u0026rdquo; du mod√®le, qui est n√©cessaire pour r√©soudre le FMTlpmodel.\nConstruire le graphe complet du mod√®le Le graphe complet du mod√®le peut √™tre construit via une r√©p√©tition de la fonction FMTlpmodel.buildperiod(). Ceci est essentiel pour r√©soudre le mod√®le, car FMT va naviguer dans ce graphe pour trouver la solution optimale en fonction de l\u0026rsquo;objectif et des contraintes que nous allons fixer (voir section suivante).\nCette fonction n√©cessite trois param√®tres :\n Un planning d\u0026rsquo;actions, sous la forme d\u0026rsquo;un objet FMTschedule (il peut √™tre vide pour obtenir le graphe complet du mod√®le, contenant toutes les possibilit√©s). Une option pour forcer une construction partielle du graphe (que nous ne verrons pas pour l\u0026rsquo;instant) Un autre param√®tre pour l\u0026rsquo;op√©rabilit√© de la classe (que nous ne verrons pas non plus pour l\u0026rsquo;instant, et juste mis √† 1)  Voici le code pour construire le graphe complet dans R. Notez la boucle for qui construit les diff√©rentes p√©riodes.\nlibrary(FMT) # Charge FMT dans R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # V√©rifie si FMT a √©t√© compil√© avec OSI en cr√©ant un nouvel objet FMTversion, et en utilisant la fonction hasfeature().\r{\r# Cr√©ation de l'objet parser pour lire les fichiers de mod√®le\rnewparser \u0026lt;- new(FMTmodelparser)\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rsolverinterface \u0026lt;- list(CLP=1,MOSEK=2,CPLEX=3,GUROBI=4)\rlpmodel \u0026lt;- new(FMTlpmodel,modelslist[[1]],solverinterface$MOSEK)\r# Nous cr√©ons un calendrier vide pour cr√©er le graphe complet\remptyschedule \u0026lt;- new(FMTschedule)\r# On fait une boucle autour des diff√©rentes p√©riodes pour construire le graphe complet\rfor (period in 1:10)\r{\r# On affiche ce qui se passe dans le terminal\rprint(lpmodel$buildperiod(emptyschedule,FALSE,1)$str())\r}\r} else { # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\r L\u0026rsquo;√©quivalent en code Python est le suivant (notez qu\u0026rsquo;en Python, nous n\u0026rsquo;avons pas besoin de faire un calendrier vide pour construire le graphique complet) :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Cr√©ation de l'objet parser pour lire les fichiers de mod√®le\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist = newmodelparser.readproject(path, scenarios)\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rlpmodel = Models.FMTlpmodel(modelslist[0], Models.FMTsolverinterface.CLP)\r# On fait une boucle autour des diff√©rentes p√©riodes pour construire le graphe complet\rfor period in range(1, 11):\rprint(lpmodel.buildperiod())\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;) # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\r La sortie des deux codes devrait √™tre la suivante :\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\rColumns: 58 Rows: 29 Vertices: 60 Edges: 58 Transfer Rows: 29 Output Rows: 0 Output Columns: 0\rColumns: 169 Rows: 87 Vertices: 141 Edges: 169 Transfer Rows: 87 Output Rows: 0 Output Columns: 0\rColumns: 336 Rows: 164 Vertices: 237 Edges: 336 Transfer Rows: 164 Output Rows: 0 Output Columns: 0\rColumns: 553 Rows: 259 Vertices: 350 Edges: 553 Transfer Rows: 259 Output Rows: 0 Output Columns: 0\rColumns: 805 Rows: 372 Vertices: 481 Edges: 805 Transfer Rows: 372 Output Rows: 0 Output Columns: 0\rColumns: 1088 Rows: 503 Vertices: 630 Edges: 1088 Transfer Rows: 503 Output Rows: 0 Output Columns: 0\rColumns: 1407 Rows: 652 Vertices: 797 Edges: 1407 Transfer Rows: 652 Output Rows: 0 Output Columns: 0\rColumns: 1762 Rows: 819 Vertices: 982 Edges: 1762 Transfer Rows: 819 Output Rows: 0 Output Columns: 0\rColumns: 2177 Rows: 1015 Vertices: 1196 Edges: 2177 Transfer Rows: 1015 Output Rows: 0 Output Columns: 0\rColumns: 2660 Rows: 1244 Vertices: 1443 Edges: 2660 Transfer Rows: 1244 Output Rows: 0 Output Columns: 0\r Comme on peut le voir, le terminal nous montre l\u0026rsquo;√©volution des caract√©ristiques du FMTgraph au fur et √† mesure de sa construction (nombre croissant de colonnes, de liens, etc.).\nContraintes et objectif Les mod√®les de programmation lin√©aire sont accompagn√©s de contraintes et d\u0026rsquo;un objectif, pour lesquels nous voulons une solution optimis√©e.\nPar cons√©quent, pour r√©soudre un FMTlpmodel, nous devons d√©finir ces contraintes et objectifs dans le mod√®le avant de tenter de le r√©soudre.\nCes contraintes et objectifs peuvent √™tre d√©finis manuellement via les fonctions FMTlpmodel.setobjective() et FMTlpmodel.setconstraints().\nLa plupart du temps, vous allez finir par faire ce qui suit :\n R√©cup√©rer les contraintes qui sont d√©j√† dans la formulation des fichiers Woodstock du mod√®le en utilisant la fonction FMTmodel.getconstraint(). Retirer la premi√®re contrainte de la liste des contraintes que FMTmodel.getconstraint() renvoie, car la premi√®re contrainte de cette liste est en fait l\u0026rsquo;objectif du mod√®le. Ensuite, ins√©rer cet objectif et les contraintes dans le FMTlpmodel afin de le r√©soudre, en utilisant les fonctions FMTlpmodel.setobjective() et FMTlpmodel.setconstraint().  Cela donnera le code suivant, dans R :\nlibrary(FMT) # Charge FMT dans R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # V√©rifie si FMT a √©t√© compil√© avec OSI en cr√©ant un nouvel objet FMTversion, et en utilisant la fonction hasfeature().\r{\r# Cr√©ation de l'objet parser pour lire les fichiers de mod√®le\rnewparser \u0026lt;- new(FMTmodelparser)\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rsolverinterface \u0026lt;- list(CLP=1,MOSEK=2,CPLEX=3,GUROBI=4)\rlpmodel \u0026lt;- new(FMTlpmodel,modelslist[[1]],solverinterface$MOSEK)\r# Nous cr√©ons un calendrier vide pour cr√©er le graphe complet\remptyschedule \u0026lt;- new(FMTschedule)\r# On fait une boucle autour des diff√©rentes p√©riodes pour construire le graphe complet\rfor (period in 1:10)\r{\r# On affiche ce qui se passe dans le terminal\rprint(lpmodel$buildperiod(emptyschedule,FALSE,1)$str())\r}\r# On r√©cup√®re les contraintes et objectifs\rallmodelconstraints \u0026lt;- lpmodel$getconstraints()\r# On d√©finit la premi√®re contrainte de la liste comme l'objectif du mod√®le\rmodelobjective \u0026lt;- allmodelconstraints[[1]]\r# On d√©finit toutes les autres contraintes de la liste comme les contraintes du mod√®le\rmodelconstraints \u0026lt;- allmodelconstraints[2:length(allmodelconstraints)]\r# On applique toutes les contraintes dans le mod√®le\rfor (constraint in modelconstraints)\r{\rprint(lpmodel$setconstraint(constraint)$str())\r}\r# On applique l'objectif au mod√®le\rprint(lpmodel$setobjective(modelobjective)$str())\r} else { # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\r L\u0026rsquo;√©quivalent en code Python est le suivant (remarquez qu\u0026rsquo;ici, nous allons juste \u0026ldquo;sortir\u0026rdquo; la fonction objectif de la liste des contraintes retourn√©e par FMTlpmodel.getconstraints() avec la fonction list.pop(), ce qui nous permet de boucler directement sur la liste restante pour les contraintes) :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Cr√©ation de l'objet parser pour lire les fichiers de mod√®le\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# Lit le projet avec le parser en sp√©cifiant que l'on veut lire le sc√©nario \u0026quot;LP\u0026quot; (il peut y avoir diff√©rents sc√©narios dans un seul mod√®le)\rmodelslist = newmodelparser.readproject(path, scenarios)\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rlpmodel = Models.FMTlpmodel(modelslist[0], Models.FMTsolverinterface.CLP)\r# On fait une boucle autour des diff√©rentes p√©riodes pour construire le graphe complet\rfor period in range(1, 11):\rprint(lpmodel.buildperiod())\r# On r√©cup√®re les contraintes et objectifs\rconstraints = lpmodel.getconstraints()\r# On d√©finit la premi√®re contrainte de la liste comme l'objectif du mod√®le\robjective = constraints.pop(0)\r# On applique toutes les contraintes dans le mod√®le\rfor constraint in constraints:\rlpmodel.setconstraint(constraint)\r# On applique l'objectif au mod√®le\rlpmodel.setobjective(objective)\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;) # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\r R√©soudre le FMTlpmodel Une fois que le graphe complet est construit, et que les contraintes et les objectifs sont fix√©s, le FMTlpmodel peut √™tre r√©solu en utilisant la fonction FMTlpmodel.initialsolve(). La fonction renvoie une valeur true ou false selon que le mod√®le a √©t√© r√©solu avec succ√®s. Si la r√©solution s\u0026rsquo;est bien pass√©e, le mod√®le conserve la solution et cette derni√®re peut √™tre interroger de diff√©rente mani√®res (un exemple est pr√©sent√© plus bas).\nConstruire le graphe avec une solution existante (construction partielle) Parfois, on peut vouloir obtenir des r√©sultats d\u0026rsquo;une solution/planification que l\u0026rsquo;on a d√©j√† d√©j√† (voir la section suivante) sans r√©soudre le mod√®le √† nouveau, puisqu\u0026rsquo;il a d√©j√† √©t√© r√©solu pr√©c√©demment.\nDans ce cas, il est possible de lire une solution qui a √©t√© trouv√©e pr√©c√©demment, et de construire le FMTgraph du mod√®le en g√©n√©rant seulement les noeuds et les liens utilis√©s par la solution.\nPour cela, trois choses doivent √™tre faites :\n Lire le fichier de calendrier du sc√©nario, et le passer √† la fonction FMTlpmodel.buildperiod(). D√©finir la solution pour chaque p√©riode avec la fonction FMTlpmodel.setsolution().  Si le mod√®le contient plusieurs actions _LOCKEXEMPT, l\u0026rsquo;utilisation de FMTlpmodel.setsolution() peut provoquer des erreurs car les verrous ne font pas partie de la solution. Dans ce cas, vous devez utiliser la fonction FMTlpmodel.setsolutionbylp().    Cela donnera le code suivant, dans R :\nlibrary(FMT) # Charge FMT dans R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # V√©rifie si FMT a √©t√© compil√© avec OSI en cr√©ant un nouvel objet FMTversion, et en utilisant la fonction hasfeature().\r{\r# Cr√©ation de l'objet parser pour lire les fichiers de mod√®le\rnewparser \u0026lt;- new(FMTmodelparser)\r# Indique o√π le mod√®le et la solution existante se trouvent\rprimarylocation \u0026lt;- \u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rmodelslist \u0026lt;- newmodelparser$readproject(primarylocation, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rsolverinterface \u0026lt;- list(CLP=1,MOSEK=2,CPLEX=3,GUROBI=4)\rlpmodel \u0026lt;- new(FMTlpmodel,modelslist[[1]],solverinterface$MOSEK)\r# On lit le calendrier existant, qui est le premier √©l√©ment de la liste renvoy√© par la fonction\rschedules \u0026lt;- newparser$readschedules(primarylocation,modelslist)[[1]]\r# On cr√©er une variable \u0026quot;tolerance\u0026quot; qui est n√©c√©ssaire pour la fonction setsolution()\rtolerance \u0026lt;- 0.0001\r# On fait une boucle autour des p√©riodes pour construire le graphe partiel avec la solution existante\rfor (period in 1:length(schedules))\r{\rprint(lpmodel$buildperiod(schedules[[period]],TRUE,1)$str())\r}\r# On definit la solution du mod√®le √† chaque periode comme celle qui existait au depart\rfor (period in 1:length(schedules))\r{\r# On fait en sorte que le terminal nous affiche quelque chose si la solution a bien √©t√© d√©finie pour cette p√©riode\rif (lpmodel$setsolution(period, schedules[[period]], tolerance))\r{\rprint(paste(\u0026quot;Solution set at period \u0026quot;, period))\r}\r}\r} else { # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\r Remarquez qu\u0026rsquo;ici, on applique un deuxi√®me param√®tre TRUE √† lpmodel$buildperiod() pour indiquer que nous voulons forcer une construction partielle, comme indiqu√© dans la documentation de la fonction :\n  Remarquez √©galement que nous avons cr√©√© une variable nomm√©e tolerance, qui est n√©cessaire √† la fonction lpmodel$setsolution(), comme l\u0026rsquo;indique la documentation une fois de plus :\n  L\u0026rsquo;√©quivalent en code Python est le suivant :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Cr√©ation de l'objet parser pour lire les fichiers de mod√®le\rnewmodelparser= Parser.FMTmodelparser()\r# Indique o√π le mod√®le et la solution existante se trouvent\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rmodelslist = newmodelparser.readproject(path, scenarios)\r# On met le mod√®le dans le format \u0026quot;lpmodel\u0026quot; pour le mod√®le de programmation lin√©aire, en sp√©cifiant le solveur que nous voulons utiliser\rlpmodel = Models.FMTlpmodel(modelslist[0], Models.FMTsolverinterface.CLP)\r# On cr√©er une variable \u0026quot;tolerance\u0026quot; qui est n√©c√©ssaire pour la fonction setsolution()\rtolerance = 0.0001\r# On lit le calendrier existant, qui est le premier √©l√©ment de la liste renvoy√© par la fonction\rschedules = newmodelparser.readschedules(path, modellist)[0]\r# On fait une boucle autour des p√©riodes pour construire le graphe partiel avec la solution existante\rfor periodschedule in range(len(schedules)):\rprint(lpmodel.buildperiod(schedules[periodschedule], False, 1))\r# On definit la solution du mod√®le √† chaque periode comme celle qui existait au depart (on utilise +1 pour s'adapter au fait que Python commence ses listes √† 0)\rfor periodschedule in range(len(schedules)):\rlpmodel.setsolution(periodschedule+1, schedules[periodschedule], tolerance)\rprint(\u0026quot;Solution set at period\u0026quot;, periodschedule+1) else:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;) # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\r La sortie des deux codes devrait √™tre la suivante :\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\rColumns: 20 Rows: 10 Vertices: 28 Edges: 20 Transfer Rows: 10 Output Rows: 0 Output Columns: 0\rColumns: 40 Rows: 25 Vertices: 48 Edges: 40 Transfer Rows: 25 Output Rows: 0 Output Columns: 0\rColumns: 63 Rows: 44 Vertices: 71 Edges: 63 Transfer Rows: 44 Output Rows: 0 Output Columns: 0\rColumns: 90 Rows: 67 Vertices: 98 Edges: 90 Transfer Rows: 67 Output Rows: 0 Output Columns: 0\rColumns: 123 Rows: 95 Vertices: 131 Edges: 123 Transfer Rows: 95 Output Rows: 0 Output Columns: 0\rColumns: 157 Rows: 126 Vertices: 165 Edges: 157 Transfer Rows: 126 Output Rows: 0 Output Columns: 0\rColumns: 198 Rows: 162 Vertices: 206 Edges: 198 Transfer Rows: 162 Output Rows: 0 Output Columns: 0\rColumns: 244 Rows: 203 Vertices: 252 Edges: 244 Transfer Rows: 203 Output Rows: 0 Output Columns: 0\rColumns: 294 Rows: 248 Vertices: 301 Edges: 294 Transfer Rows: 248 Output Rows: 0 Output Columns: 0\rColumns: 351 Rows: 298 Vertices: 356 Edges: 351 Transfer Rows: 298 Output Rows: 0 Output Columns: 0\rColumns: 405 Rows: 350 Vertices: 410 Edges: 405 Transfer Rows: 350 Output Rows: 0 Output Columns: 0\rColumns: 467 Rows: 407 Vertices: 472 Edges: 467 Transfer Rows: 407 Output Rows: 0 Output Columns: 0\rColumns: 532 Rows: 468 Vertices: 537 Edges: 532 Transfer Rows: 468 Output Rows: 0 Output Columns: 0\rColumns: 599 Rows: 532 Vertices: 604 Edges: 599 Transfer Rows: 532 Output Rows: 0 Output Columns: 0\rColumns: 673 Rows: 601 Vertices: 678 Edges: 673 Transfer Rows: 601 Output Rows: 0 Output Columns: 0\rColumns: 745 Rows: 671 Vertices: 749 Edges: 745 Transfer Rows: 671 Output Rows: 0 Output Columns: 0\rColumns: 828 Rows: 747 Vertices: 831 Edges: 828 Transfer Rows: 747 Output Rows: 0 Output Columns: 0\rColumns: 912 Rows: 827 Vertices: 915 Edges: 912 Transfer Rows: 827 Output Rows: 0 Output Columns: 0\rColumns: 998 Rows: 910 Vertices: 1001 Edges: 998 Transfer Rows: 910 Output Rows: 0 Output Columns: 0\rColumns: 1091 Rows: 998 Vertices: 1094 Edges: 1091 Transfer Rows: 998 Output Rows: 0 Output Columns: 0\rSolution set at period 1\rSolution set at period 2\rSolution set at period 3\rSolution set at period 4\rSolution set at period 5\rSolution set at period 6\rSolution set at period 7\rSolution set at period 8\rSolution set at period 9\rSolution set at period 10\rSolution set at period 11\rSolution set at period 12\rSolution set at period 13\rSolution set at period 14\rSolution set at period 15\rSolution set at period 16\rSolution set at period 17\rSolution set at period 18\rSolution set at period 19\rSolution set at period 20\r Obtenir des valeurs de sortie du mod√®le Il existe plusieurs fa√ßons de lire les diff√©rentes sorties du mod√®le.\nEn R, il existe une fonction particuli√®re (seulement disponible en R) appel√©e getoutsdataframe() ; mais pour R, Python et C++, il est possible d\u0026rsquo;utiliser la fonction FMTmodel.getoutputs() pour obtenir une liste des sorties (outputs) disponibles pour un mod√®le donn√©.\nIl est possible de s√©lectionner un FMToutputlevel diff√©rent afin d\u0026rsquo;obtenir une sortie √† diff√©rentes √©chelles dans le mod√®le.\nPour un exemple, voir exercice 1.\nExportation du calendrier d\u0026rsquo;un mod√®le r√©solu L\u0026rsquo;exportation du calendrier d\u0026rsquo;un mod√®le r√©solu se fait via l\u0026rsquo;objet FMTscheduleparser que nous avons utilis√© lors de la construction du graphe partiel (voir sections pr√©c√©dentes).\nLa solution d\u0026rsquo;un mod√®le peut √™tre mise dans une liste en utilisant la fonction FMTlpmodel.getsolution() pour chacune des p√©riodes d\u0026rsquo;int√©r√™t.\nEnsuite, la liste des solutions pour chaque p√©riode doit √™tre transform√©e en un vecteur, qui peut ensuite √™tre √©crit dans un fichier .txt en utilisant la fonction FMTscheduleparser.write().\nPour un exemple, voir exercice 1.\nPr√©-solution d\u0026rsquo;un mod√®le Certains mod√®les peuvent √™tre difficiles √† r√©soudre, √† cause de leur nombre √©lev√© d\u0026rsquo;actions, de strates, et ainsi de suite.\nDans ce cas, la fonction FMTmodel.basepresolve() peut √™tre utilis√©e pour pr√©-solutioner le mod√®le.\nCette fonction retourne un mod√®le avec moins de th√®mes, d\u0026rsquo;actions, de transitions, de sorties et de contraintes que le mod√®le original, mais avec la m√™me quantit√© d\u0026rsquo;informations. Cela le rend plus facile √† r√©soudre, tout en donnant la m√™me r√©ponse √† la fin.\nDans certaines situations, FMT pr√©-solutionerra le mod√®le automatiquement.\n Maintenant que vous savez tout ce qu\u0026rsquo;il y a √† savoir sur l\u0026rsquo;optimisation √† spatialement r√©f√©renc√©e dans FMT, nous vous recommandons d\u0026rsquo;essayer l\u0026rsquo;exercice 1 pour vous aider √† apprendre √† utiliser FMT en pratique. Dans cet exercice, vous apprendrez √† utiliser par vous-m√™me certaines des fonctions les plus r√©guli√®rement utilis√©es.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"1944b4f83faa7919c3330c50fbf3bbde","permalink":"https://bureau-du-forestier-en-chef.github.io/FMT/fr/docs/basics/spatially_referenced_optimization/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMT/fr/docs/basics/spatially_referenced_optimization/","section":"docs","summary":"Dans la section pr√©c√©dente, nous avons vu comment lire un mod√®le Woodstock et le charger dans un objet FMTlpmodel.\nFMTlpmodel vous permettra de r√©soudre un mod√®le de programmation lin√©aire √† spatialement r√©f√©renc√©, ce qui vous donnera un calendrier (schedule) optimis√© d\u0026rsquo;op√©rations foresti√®res en fonction d\u0026rsquo;un objectif et d\u0026rsquo;un ensemble de contraintes.","tags":null,"title":"Optimisation spatiallement r√©f√©renc√©e","type":"book"},{"authors":null,"categories":null,"content":" Si git n\u0026rsquo;est pas install√© sur votre ordinateur, installez-le depuis ce lien.   Git est un logiciel libre et gratuit utilis√© pour aider √† organiser la fa√ßon dont les gens cr√©ent le code source de programmes ou d\u0026rsquo;outils, et comment ils collaborent pour le faire.\nIci, git vous aidera √† t√©l√©charger le code utilis√© pour faire fonctionner le logiciel vcpkg, qui t√©l√©chargera toutes les librairies dont FMT a besoin pour le compiler.\n  Utilisez git clone https://github.com/microsoft/vcpkg.git dans l\u0026rsquo;invite de commande pour t√©l√©charger vcpkg.   Si vous avez ferm√© l\u0026rsquo;invite de commande, ou si vous ne vous souvenez pas comment l\u0026rsquo;ouvrir, consultez la page pr√©c√©dente.   Utilisez cd ./vcpkg dans l\u0026rsquo;invite de commande pour naviguer dans le dossier vcpkg.   Si vous ne vous souvenez pas comment utiliser cd, consultez la page pr√©c√©dente.   Copiez/collez la commande suivante dans l\u0026rsquo;invite de commande pour installer les d√©pendances et librairies n√©cessaires √† la compilation de FMT grace √† vcpkg :  vcpkg install boost:x64-windows boost-dll:x64-windows boost-icl:x64-windows boost-python:x64-windows gdal:x64-windows geos:x64-windows pthreads:x64-windows clp:x64-windows\r  Cela prendra du temps, et utilisera un certain espace sur votre ordinateur (environ 10 Go).\nLaissez juste l\u0026rsquo;invite de commande ouverte pour que vcpkg fasse son travail.\n   Une fois que vcpkg est termin√©, passez √† la page suivante.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"bfc7fa201cc9979fa31631fd6f787541","permalink":"https://bureau-du-forestier-en-chef.github.io/FMT/fr/docs/download_install/downloading_libraries/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMT/fr/docs/download_install/downloading_libraries/","section":"docs","summary":"Si git n\u0026rsquo;est pas install√© sur votre ordinateur, installez-le depuis ce lien.   Git est un logiciel libre et gratuit utilis√© pour aider √† organiser la fa√ßon dont les gens cr√©ent le code source de programmes ou d\u0026rsquo;outils, et comment ils collaborent pour le faire.","tags":null,"title":"T√©l√©charger les librairies","type":"book"},{"authors":null,"categories":null,"content":"Maintenant que tout est pr√™t, il est temps de passer √† l\u0026rsquo;√©tape de compilation proprement dite.\n  Utilisez cd .. pour retourner dans le dossier FMT-Installation.\n  Clonez le repository de FMT en utilisant git clone https://github.com/gcyr/FMT.git.\n  Utilisez cd ./FMT pour naviguer dans le dossier FMT t√©l√©charg√© depuis le repository de FMT.\n  Copiez/collez les commandes suivantes dans le bloc-notes de Windows, puis remplacez le param√®tre -DMOSEK_DIR par l\u0026rsquo;emplacement de Mosek sur votre ordinateur :\n  cmake CMakeLists.txt -B build/release -G \u0026quot;Visual Studio 16 2019\u0026quot; -DVCPKG_TARGET_TRIPLET=x64-windows -DCMAKE_TOOLCHAIN_FILE=\u0026quot;../vcpkg/scripts/buildsystems/vcpkg.cmake\u0026quot; -DBOOST_DIR=\u0026quot;../vcpkg/installed/x64-windows/\u0026quot; -DCMAKE_BUILD_TYPE=Release -DGDAL_DIR=\u0026quot;. ./vcpkg/installed/x64-windows/\u0026quot; -DGEOS_DIR=\u0026quot;../vcpkg/installed/x64-windows/\u0026quot; -DOSI_DIR=\u0026quot;../vcpkg/installed/x64-windows/\u0026quot; -DPYTHON_DIR=\u0026quot;../vcpkg/packages/python3_x64-windows/\u0026quot; -DMOSEK_DIR=\u0026quot;C:/PROGRA~1/Mosek/\u0026quot;\rcmake --build build/release --config Release\rcmake --install build/release --config Release\r  Par d√©faut, Mosek est install√© dans votre dossier C:/Program Files sous Windows. Ceci peut √™tre exprim√© par le chemin C:/PROGRA~1 pour √©viter l\u0026rsquo;espace entre Program et Files, qui peut cr√©er des erreurs.\nAinsi, si vous avez install√© Mosek dans C:\\Program Files\\Mosek, vous pouvez conserver C:/PROGRA~1/Mosek/ dans ces commandes.\n  Copiez/collez toutes les commandes qui sont pr√™tes dans le bloc-notes vers l\u0026rsquo;invite de commande pour lancer la compilation. Appuyez sur la touche Entr√©e pour les activer.   Cela prendra du temps, et vous pourriez voir des avertissements dans l\u0026rsquo;invite de commande pendant le processus. Ne vous en inqui√©tez pas.    Si la compilation se termine par des messages d\u0026rsquo;erreur en rouge, vous pouvez poster un probl√®me sur la page des probl√®mes du repository de FMT.    Si tout a fonctionn√©, f√©licitations ! Il ne nous reste plus qu\u0026rsquo;√† importer FMT dans Python et √† v√©rifier que tout fonctionne.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"28b33694d2653cd0b0dcc16d3adf2fb2","permalink":"https://bureau-du-forestier-en-chef.github.io/FMT/fr/docs/download_install/compiling/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMT/fr/docs/download_install/compiling/","section":"docs","summary":"Maintenant que tout est pr√™t, il est temps de passer √† l\u0026rsquo;√©tape de compilation proprement dite.\n  Utilisez cd .. pour retourner dans le dossier FMT-Installation.\n  Clonez le repository de FMT en utilisant git clone https://github.","tags":null,"title":"Compiler","type":"book"},{"authors":null,"categories":null,"content":"Dans cet exercice, vous allez essayer d\u0026rsquo;utiliser FMT pour lire un sc√©nario, le r√©soudre, lire une de ses sorties, et exporter la solution.\nPour faire cet exercice, vous devez avoir install√© FMT sur votre ordinateur et avoir t√©l√©charg√© les fichiers d\u0026rsquo;exemple depuis le d√©p√¥t GitHub de FMT.\n üíæ T√©l√©charger et installer FMT    üíæ T√©l√©charger les fichiers d\u0026rsquo;exemples de FMT   Objectifs de l\u0026rsquo;exercice Utilisez FMT pour :\n Lire le mod√®le Woodstock TWD_land dans les fichiers d\u0026rsquo;exemple en s√©lectionnant son sc√©nario nomm√© LP.  N\u0026rsquo;oubliez pas de s√©lectionner le solveur CLP lors de la lecture du mod√®le.   R√©solvez le mod√®le en  Construisant son graphe complet pour 10 p√©riodes D√©finissant l\u0026rsquo;objectif et les contraintes du mod√®le Utilisant la fonction FMTmodel.initialsolve() pour le r√©soudre.   Lire les valeurs de la sortie OSUPREC du mod√®le en  Obtenant une liste des sorties du mod√®le avec la fonction FMTmodel.getouputs(). Effectuant une boucle for pour s√©lectionner la bonne sortie avec la fonction FMToutput.getname(). Imprimer les valeurs de la sortie avec la fonction FMTmodel.getvariabilities(FMToutput).   Exportez le calendrier optimis√© du mod√®le dans un fichier .txt en  Cr√©ant un nouvel objet FMTscheduleparser. R√©cup√©rant la solution du mod√®le √† chaque p√©riode avec une liste en utilisant LPModel.getsolution(period). Transformant la liste en un vecteur √âcriture du vecteur dans un fichier .txt avec FMTscheduleparser.write().    Vous pouvez utiliser les informations des pages pr√©c√©dentes de la documentation pour vous aider.\nLorsque vous avez termin√©, ou si vous √™tes bloqu√©, vous pouvez afficher la correction de cet exercice pour du coe Python en cliquant sur le bouton \u0026ldquo;R√©v√©ler la correction\u0026rdquo; ci-dessous.\nCorrection R√©v√©ler la correction #%% CHARGEMENT DE FMT\r# Ici, on charge FMT directement, comme si il avait √©t√© install√© avec pip.\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\r#%% CHARGEMENT DU MOD√àLE WOODSTOCK\r# Cr√©ation d'un objet pour lire le mod√®le (parser)\rmodelParser = Parser.FMTmodelparser()\r# Definition du chemin menant au mod√®le woodstock\r# Le mod√®le woodstock est fait de pleins de petits fichiers diff√©rents\r# On pointe vers le fichier .pri, qui contient la location de tous les petits fichiers du mod√®le.\r# WARNING : FMT a du mal avec les espaces dans les chemins. Essayez d'avoir un\r# chemin sans espaces.\rpathToWoodstockModel = \u0026quot;D:/TempCode/FMT/FMT/Examples/Models/TWD_land/TWD_land.pri\u0026quot;\r# On d√©finit le/les sc√©narios que l'on va lire\r# Les sc√©narios sont des ensembles de contraites et objectifs,\r# ou bien un planning deja fait que l'on va simuler.\rscenariosToSelect = [\u0026quot;LP\u0026quot;]\r# On lit le model grace au parser. Celui-ci va renvoyer une liste de mod√®les\r# qu'il a d√©t√©ct√©. Dans notre cas, on n'en aura qu'un seul.\rlistOfModelsParsed = modelParser.readproject(pathToWoodstockModel, scenariosToSelect)\r# On charge le mod√®le parmis la liste des mod√®les renvoy√©e\r# Pour le charger correctement, il faut d√©crire le type de mod√®le que c'est, ainsi que des param√®tres importants.\r# Ici, le mod√®le sera un mod√®le lin√©raire spatialement r√©f√©rence (LP),\r# et on utilisera le solveur CLP pour le r√©soudre.\rLPModel = Models.FMTlpmodel(listOfModelsParsed[0], Models.FMTsolverinterface.CLP)\r#%% R√âSOLUTION DU MOD√àLE\r# Construction des p√©riodes du mod√®le\rfor period in range(1, 11):\rprint(LPModel.buildperiod())\r# R√©cup√©ration des contraintes et de l'objectif\rconstraintsOfModel = LPModel.getconstraints()\robjectiveOfModel = constraintsOfModel.pop(0)\r# D√©finition des contraintes et de l'objectif\rfor constraint in constraintsOfModel:\rprint(LPModel.setconstraint(constraint))\rprint(LPModel.setobjective(objectiveOfModel))\r# R√©solution du mod√®le\rLPModel.initialsolve()\r#%% INTERROGATION DE OSUPREC\r# On peut lire OSUPREC avant que le mod√®le soit r√©solu, mais les valeurs ne sont pas int√©r√©ssantes si c'est le cas.\routputWanted = \u0026quot;OSUPREC\u0026quot;\r# On r√©cup√®re les sorties du mod√®le\routputsOfModel = LPModel.getoutputs()\r# On fait une boucle autour de la liste des sorties pour selecitonner celle qui a le bon nom\rfor output in outputsOfModel:\rprint(output.getname())\rif output.getname() == outputWanted:\r# On affiche les mesures de \u0026quot;OSUPREC\u0026quot; dans le terminal\rprint(LPModel.getvariabilities([output]))\r# On sauvegarde les valeurs de OSUPREC pour les mettre au propre ensuite\rosuprecValues = LPModel.getvariabilities([output])\r# Ici, c'est un petit code qui permet d'afficher les sorties\r# en s'adaptant au fait que getvariabilities() renvoie leur valeur\r# minimum, maximum et moyenne print(\u0026quot;\\n\\n ###############################\u0026quot;)\rprint(\u0026quot;Values of \u0026quot; + outputWanted + \u0026quot; :\\n\u0026quot;)\rprint(\u0026quot;PERIOD\\t\\tMINIMUM\\t\\tMEAN\\t\\tMAXIMUM\u0026quot;)\rfor period in range(1, 11):\rprint(str(period) + \u0026quot;\\t\\t\\t\u0026quot; + str(round(osuprecValues[\u0026quot;L\u0026quot;+outputWanted][period-1], 2))\r+ \u0026quot;\\t\\t\u0026quot; + str(round(osuprecValues[\u0026quot;M\u0026quot;+outputWanted][period-1], 2))\r+ \u0026quot;\\t\\t\u0026quot; + str(round(osuprecValues[\u0026quot;U\u0026quot;+outputWanted][period-1], 2)))\r#%% ECRITURE DU PLANNING (cedule)\r# On d√©clare un objet permettant d'√©crire le programme/planning/c√©dule\rscheduleParser = Parser.FMTscheduleparser()\r# On r√©cup√®re la solution du mod√®le\rmodelSolution = list()\rfor period in range(1, 11):\rmodelSolution.append(LPModel.getsolution(period))\r# On √©crit le programme avec le scheduleParser\rmodelSolutionAsVector = [[i] for i in modelSolution]\rscheduleParser.write(modelSolution, r\u0026quot;D:/TempCode/FMT/FMT/Examples/programme.txt\u0026quot;)\r  ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"c5750174bd25f564fd2b5739892c8360","permalink":"https://bureau-du-forestier-en-chef.github.io/FMT/fr/docs/basics/exercice_1/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMT/fr/docs/basics/exercice_1/","section":"docs","summary":"Dans cet exercice, vous allez essayer d\u0026rsquo;utiliser FMT pour lire un sc√©nario, le r√©soudre, lire une de ses sorties, et exporter la solution.\nPour faire cet exercice, vous devez avoir install√© FMT sur votre ordinateur et avoir t√©l√©charg√© les fichiers d\u0026rsquo;exemple depuis le d√©p√¥t GitHub de FMT.","tags":null,"title":"Exercice 1","type":"book"},{"authors":null,"categories":null,"content":"Pour importer FMT que vous venez de compiler dans Python, vous devez avoir install√© Python et pip sur votre ordinateur.\n Si Python n\u0026rsquo;est pas install√© sur votre ordinateur, nous vous recommandons d\u0026rsquo;installer Miniconda, la version \u0026ldquo;l√©g√®re\u0026rdquo; de la c√©l√®bre distribution Python Anaconda. Miniconda contient Python, pip et de nombreux autres modules qui sont utiles pour utiliser FMT.   Il existe deux fa√ßons d\u0026rsquo;importer FMT dans Python :\n En utilisant sys.path.append.  sys.path.append vous permet d\u0026rsquo;indiquer √† Python o√π trouver les biblioth√®ques de fonction de FMT.\nSi vous l\u0026rsquo;utilisez, le d√©but de vos scripts Python ressemblera √† ceci :\nimport sys\rsys.path.append(r\u0026quot;\u0026lt;Chemin vers le dossier FMT\u0026gt;/\u0026quot;)\rsys.path.append(r\u0026quot;\u0026lt;Chemin vers le dossier FMT\u0026gt;/Release/\u0026quot;)\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Core\rfrom FMT import Version\r dans lequel \u0026lt;Chemin vers le dossier FMT\u0026gt; sera remplac√© par l\u0026rsquo;emplacement du dossier o√π se trouvent les fichiers FMT que vous avez t√©l√©charg√©s depuis GitHub (et o√π se trouvent aussi les biblioth√®que de fonction compil√©es de FMT, √† pr√©sent).\nCela peut cependant devenir redondant, ce qui rend la deuxi√®me option - l\u0026rsquo;installation avec pip - plus int√©ressante.\nEn utilisant pip et la Python wheel que vous avez compil√©e.  Les Python wheels sont des fichiers qui contiennent tout ce qui est n√©cessaire pour qu\u0026rsquo;un module Python soit install√© dans votre environnement Python avec la commande pip. Une fois install√© de cette mani√®re, le module peut √™tre activ√© plus rapidement dans vos scripts Python.\nPour installer la Python wheel que vous avez compil√©e, utilisez la commande suivante dans une invite de commande (si vous avez install√© Python et pip ind√©pendamment d\u0026rsquo;Anaconda ou Miniconda), ou dans une invite de commande Anaconda :\npip install \u0026quot;\u0026lt;chemin vers le dossier FMT\u0026gt;\\build\\release\\bin\\Release/FMT-0.9.1-py3-none-any.whl\u0026quot;\r Une fois cette op√©ration effectu√©e, vous pourrez importer FMT dans vos scripts plus rapidement :\nfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Core\rfrom FMT import Version\r  Et c\u0026rsquo;est tout, vous avez termin√© üéäüéâ! Maintenant, vous pouvez commencer √† utiliser FMT !\n Si vous avez eu des probl√®mes pendant le processus de t√©l√©chargement et d\u0026rsquo;installation de FMT, veuillez poster un probl√®me sur la page de probl√®mes du repository de FMT.   ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"3b4e5515a8180b52d201ea181148e8d7","permalink":"https://bureau-du-forestier-en-chef.github.io/FMT/fr/docs/download_install/importing_in_python/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMT/fr/docs/download_install/importing_in_python/","section":"docs","summary":"Pour importer FMT que vous venez de compiler dans Python, vous devez avoir install√© Python et pip sur votre ordinateur.\n Si Python n\u0026rsquo;est pas install√© sur votre ordinateur, nous vous recommandons d\u0026rsquo;installer Miniconda, la version \u0026ldquo;l√©g√®re\u0026rdquo; de la c√©l√®bre distribution Python Anaconda.","tags":null,"title":"Importer FMT dans Python","type":"book"},{"authors":null,"categories":null,"content":"Un petit rappel sur la signification de \u0026ldquo;spatialement r√©f√©renc√©\u0026rdquo;. On peut distinguer 3 fa√ßons de prendre en compte l\u0026rsquo;espace dans un mod√®le :\n Dans un mod√®le non spatial ou mod√®le spatialement implicite, les entit√©s (par exemple, les for√™ts, les animaux, les agents, etc.) ne sont pas directement associ√©es √† une position dans l\u0026rsquo;espace, mais la relation entre elles dans le mod√®le peut impliquer que seules certaines d\u0026rsquo;entre elles interagissent entre elles de mani√®re √† mimer une disposition spatiale. Dans un mod√®le spatialement r√©f√©renc√©, les entit√©s sont associ√©es √† des r√©gions de l\u0026rsquo;espace, mais pas √† une position pr√©cise dans ces r√©gions ; ces r√©gions peuvent √™tre non-continues. Les mod√®les de Woodstock sont par nature spatialement r√©f√©renc√©s, car ils consid√®rent des strates qui correspondent √† des for√™ts de m√™me composition et de m√™me √¢ge, qui peuvent √™tre dispers√©es en de nombreux endroits du paysage. Dans un mod√®le spatialement explicite, les entit√©s sont associ√©es √† des coordonn√©es pr√©cises dans l\u0026rsquo;espace, comme dans les pixels d\u0026rsquo;une carte matricielle.  Le FMTsesmodel FMTsesmodel est un mod√®le particulier qui donne √† l\u0026rsquo;utilisateur la possibilit√© de spatialiser les solutions provenant de n\u0026rsquo;importe quelle classe FMTsrmodel, qui sont les mod√®les spatialement r√©f√©renc√©s (voir objets, lecture et interrogation de mod√®les et optimisation spatiallement r√©f√©renc√©e).\nNotez que nous ne parlons pas de l\u0026rsquo;optimisation d\u0026rsquo;un mod√®le spatialement explicite ; c\u0026rsquo;est une t√¢che assez complexe qui est encore sur le plan de route de FMT (et qui est le but de la classe FMTsamodel).\nclassDiagram\rFMTmodel \u0026lt;|-- FMTsamodel\rFMTmodel \u0026lt;|-- FMTsesmodel\rFMTmodel \u0026lt;|-- FMTsrmodel\rFMTsrmodel \u0026lt;|-- FMTlpmodel\rFMTsrmodel \u0026lt;|-- FMTnssmodel\r Au lieu de ca, le FMTsesmodel va essayer de spatialiser le calendrier d\u0026rsquo;un FMTsrmodel en pla√ßant des blocs de coupe sur une carte. Il fait cela en faisant des it√©rations dans lesquelles il simule le placement de ces blocs, et en s√©lectionnant la meilleure solution trouv√©e.\nPour utiliser une m√©taphore, cela revient √† essayer de trouver une position gagnante aux √©checs si vous n\u0026rsquo;√™tes pas capable de la trouver en r√©fl√©chissant bien au placement de vos pi√®ces d\u0026rsquo;√©checs : vous pourriez essayer de placer vos pi√®ces au hasard de nombreuses, nombreuses fois, et vous demander √† chaque fois si vous avez gagn√©, ou si vous √™tes plus proche de la victoire, et si la position des pi√®ces d\u0026rsquo;√©checs respecte les r√®gles du jeu.\nIci, FMTsesmodel essaiera de placer les blocs de coupe selon la solution d\u0026rsquo;un FMTsrmodel (qui est un calendrier d\u0026rsquo;op√©rations foresti√®res appliqu√© √† des strates spatialement r√©f√©renc√©es). Son but sera de trouver le meilleur positionnement possible, en s\u0026rsquo;accommodant au mieux des contraintes lin√©aires et spatiales qui sont donn√©es pour leur placement, et en maximisant la valeur objective (par exemple, en maximisant le bois r√©colt√©).\nCependant, cette m√©thode a peu de chance de trouver le placement optimal, s\u0026rsquo;il existe ; √† la place, plus il y a d\u0026rsquo;it√©rations pour essayer de les placer, plus il y a de chance de trouver une solution qui se rapproche le plus possible d\u0026rsquo;un placement optimal des blocs coup√©s dans l\u0026rsquo;espace. C\u0026rsquo;est pourquoi ce processus repr√©sente ce que nous appelons une heuristique.\nL\u0026rsquo;espace dans FMT FMT utilise des FMTlayers pour repr√©senter toute solution spatialement explicite.\nUn FMTlayer peut √™tre compar√© √† un fichier raster ordinaire dans lequel les pixels peuvent contenir √† peu pr√®s n\u0026rsquo;importe quel type ou classe de peuplement forestier.\nDans le FMTsesmodel, nous utilisons la classe FMTspatialschedule pour repr√©senter une solution spatialement explicite, qui est elle-m√™me une FMTlayer de FMTlinegraph.\nChaque FMTlinegraph est une version lin√©aire du FMTgraph d√©crit dans optimisation spatiallement r√©f√©renc√©e. Cela signifie qu\u0026rsquo;ils montrent l\u0026rsquo;√©volution du FMTdevelopment √† l\u0026rsquo;int√©rieur du pixel du d√©but √† la fin des p√©riodes que nous voulons prendre en compte.\nLa classe FMTspatialschedule. La classe FMTspatialschedule contient une solution spatialement explicite sous la forme d\u0026rsquo;un FMTlayer.\nElle contient une fonction importante, FMTspatialschedule.getsolutionstatus(), qui imprime des informations importantes sur la fa√ßon dont la solution contenue dans le FMTspatialschedule atteint l\u0026rsquo;objectif du mod√®le.\nCette fonction donne √©galement une valeur de l\u0026rsquo;infaisabilit√© primaire, qui donne une id√©e de la mesure dans laquelle la solution actuelle ne respecte pas toutes les contraintes lin√©aires et spatiales du mod√®le.\nNotez que contrairement √† l\u0026rsquo;objet FMTschedule qui ne concerne qu\u0026rsquo;une seule p√©riode de temps (c\u0026rsquo;est pourquoi le code montr√© dans la section sur l\u0026rsquo;optimisation spatialement r√©f√©renc√©e contenait une boucle for autour du nombre de p√©riodes d\u0026rsquo;int√©r√™t lorsqu\u0026rsquo;il s\u0026rsquo;agissait de la classe FMTschedule), FMTspatialschedule contient une solution pour plusieurs p√©riodes de temps √† la fois.\nLe FMTlinegraph Comme dit pr√©c√©demment, la structure spatiale d\u0026rsquo;un FMTsesmodel est comme une carte raster faite de pixels, chaque pixel √©tant un FMTlinegraph.\nDans un FMTlinegraph, chaque noeud repr√©sente l\u0026rsquo;√©tat des strates √† l\u0026rsquo;int√©rieur du pixel et chaque lien repr√©sente une action (par exemple une coupe totale) ou une croissance naturelle, comme le montre l\u0026rsquo;image suivante :\n  Cependant, contrairement √† l\u0026rsquo;objet FMTgraph d√©crit dans la section sur l\u0026rsquo;optimisation spatialement r√©f√©renc√©e, le FMTlinegraph ne contient pas une √©num√©ration compl√®te de toutes les actions et √©tats possibles pour les strates dans le pixel : au lieu de cela, il ne contient qu\u0026rsquo;une solution, ou une √©volution possible pour les strates.\nFaire des transitions avec des sorties uniques Une limitation de la classe FMTlinegraph est que l\u0026rsquo;on ne peut pas utiliser de transitions √† sorties multiples, c\u0026rsquo;est-√†-dire des transitions qui aboutissent √† deux strates ou d\u0026rsquo;autres sorties, comme illustr√© ci-dessous :\n  Par cons√©quent, vous devrez modifier les transitions d\u0026rsquo;un FMTmodel pour pouvoir les utiliser dans un FMTsesmodel.\n√Ä cette fin, vous pouvez utiliser la fonction FMTtransition.single(), qui transforme automatiquement les transitions √† sorties multiples en transitions √† sortie unique.\nUne fois que les transitions ont √©t√© transform√©es en transitions uniques, vous pouvez utiliser la fonction FMTsesmodel.settransitions() pour int√©grer les nouvelles transitions g√©n√©r√©es dans le FMTsesmodel.\n√âv√©nements spatiaux Le FMTspatialschedule garde √©galement la trace des zones affect√©es par des actions particuli√®res sous la forme d\u0026rsquo;√©v√©nements spatiaux avec la classe FMTevent, comme illustr√© ici :\n  FMTevent peut repr√©senter tout type de perturbation spatialement explicite (coupe, feu, etc.). Il est associ√© √† la p√©riode de temps de l\u0026rsquo;√©v√©nement, et aux coordonn√©es de l\u0026rsquo;√©v√©nement spatial.\n  La carte foresti√®re initiale En tant que mod√®le spatialement explicite, le FMTsesmodel n√©cessite des informations spatialement explicites sur les for√™ts du paysage au d√©but de l\u0026rsquo;horizon de planification.\nPour obtenir ces informations √† partir d\u0026rsquo;un mod√®le Woodstock (qui peut avoir servi √† cr√©er un FMTlpmodel que vous avez optimis√© ; voir optimisation spatialement r√©f√©renc√©e), vous devrez r√©cup√©rer ces informations √† partir du fichier vectoriel qui sert de carte au mod√®le Woodstock. Ce fichier vectoriel contient des informations sur les attributs theme, age et lock pour chaque strate qui devront √™tre transf√©r√©es dans plusieurs rasters spatialement explicites.\nToutes ces informations seront contenues dans l\u0026rsquo;objet FMTforest, qui est l\u0026rsquo;√©quivalent de la carte du mod√®le, mais qui est bas√© sur un FMTlayer. Chaque pixel d\u0026rsquo;un objet FMTforest contient un objet FMTactualdevelopment.\nLa classe FMTareaparser peut √™tre utilis√©e pour g√©n√©rer le FMTforest n√©cessaire au FMTsesmodel, car elle contient des fonctions pour lire les cartes vectorielles ou matricielles d\u0026rsquo;un mod√®le Woodstock.\n FMTareaparser.vectormaptoFMTforest() vous permet de lire une carte vectorielle (shapefile) existante FMTareaparser.readrasters() vous permet de lire des cartes raster existantes  Ces deux fonctions requi√®rent plusieurs param√®tres pour identifier correctement les th√®mes n√©cessaires, et pour sp√©cifier plusieurs caract√©ristiques spatiales de la classe FMTforest que vous allez cr√©er.\nUne fois que la FMTforest est cr√©√©e, elle doit √™tre fournie au FMTsesmodel en utilisant la fonction FMTsesmodel.setinitialmapping().\nUtilisation de nouveaux mots-cl√©s dans les fichiers Woodstock pour les contraintes spatiales Dans un mod√®le Woodstock habituel, les contraintes spatiales ne sont pas prises en compte. Cependant, vous aurez certainement besoin d\u0026rsquo;en utiliser pour une simulation spatiale avec le FMTsesmodel, afin de placer les blocs de coupe du planning optimis√©.\nA cette fin, FMT peut lire deux nouveaux mots-cl√©s dans la section optimize d\u0026rsquo;un mod√®le Woodstock qui n\u0026rsquo;existent pas dans la syntaxe originale de Woodstock.\nCes mots-cl√©s sont _SIZE et _ADJACENCY.\n_SIZE doit √™tre utilis√© avec la syntaxe suivante dans la section optimize d\u0026rsquo;un mod√®le Woodstock :\n_SIZE(ACTION, NEIGHBORSIZE) \u0026gt;= \u0026lt;TAILLE EN PIXELS\u0026gt; \u0026lt;P√âRIODES\u0026gt;\nNotez que :\n ACTION peut √©galement √™tre un agr√©gat de plusieurs actions, de sorte que plusieurs actions peuvent √™tre soumises √† la m√™me contrainte. NEIGHBORSIZE d√©crit comment l\u0026rsquo;√©v√©nement spatial s\u0026rsquo;est propag√© d\u0026rsquo;un pixel √† un autre pixel, en suivant ce graphique :   \u0026lt;PERIODS\u0026gt; correspondent √† la p√©riode de temps pour laquelle il faut fixer la contrainte.  Ainsi, la contrainte _SIZE peut donner une taille minimale ou maximale pour les √©v√©nements des actions sp√©cifi√©es, en nombre de pixels contigus. Elle entra√Ænera la cr√©ation de blocs spatiaux de pixels o√π l\u0026rsquo;action a √©t√© appliqu√©e.\nParall√®lement, _ADJACENCY est utilis√© avec la syntaxe suivante :\n_ADJACENCY(ACTION, GREENUP) \u0026gt;= \u0026lt;DISTANCE\u0026gt; \u0026lt;P√âRIODES\u0026gt;.\nAvec :\n ACTION peut √† nouveau √™tre un agr√©gat de plusieurs actions, de sorte que plusieurs actions peuvent √™tre soumises √† la m√™me contrainte. \u0026lt;PERIODS\u0026gt; correspond √† nouveau √† la p√©riode de temps pour laquelle il faut fixer la contrainte. DISTANCE correspond √† la distance d\u0026rsquo;adjacence minimale ou maximale entre deux blocs spatiaux d\u0026rsquo;une ou plusieurs actions (dont la taille a √©t√© d√©finie par _SIZE). Ainsi, pour une DISTANCE \u0026gt;= 3, on aura ce qui suit :   Les GREENUP correspondent au nombre de p√©riodes de temps pour lesquelles nous consid√©rons que deux √©v√©nements sont voisins. Par exemple, si GREENUP est √©gal √† 3, deux blocs spatiaux d\u0026rsquo;actions qui sont sous la distance maximale indiqu√©e par DISTANCE mais qui sont s√©par√©s temporellement par 4 p√©riodes ne seront pas consid√©r√©s comme spatialement adjacents ; cependant, s\u0026rsquo;ils √©taient s√©par√©s par 3, 2 ou 1 p√©riode, ou sont dans la m√™me p√©riode, ils seront consid√©r√©s comme spatialement adjacents.  Faire la simulation avec FMTsesmodel.Greedyreferencebuild() Une fois que vous avez une solution/ un calendrier spatialement r√©f√©renc√© (voir optimisation spatialement r√©f√©renc√©) et que vous avez d√©fini le paysage initial pour le FMTsesmodel (voir les sections pr√©c√©dentes), vous pouvez utiliser FMTsesmodel.Greedyreferencebuild() pour faire la simulation proprement dite, et obtenir un calendrier d\u0026rsquo;op√©rations spatialement explicite bas√©e sur le calendrier d\u0026rsquo;op√©rations spatialement r√©f√©renc√©.\nFMTsesmodel.Greedyreferencebuild() a besoin de la solution spatialement r√©f√©renc√©e d\u0026rsquo;un FMTlpmodel (ou d\u0026rsquo;un FMTnssmodel), sous la forme d\u0026rsquo;un objet FMTschedule. Cette solution d√©crit quel d√©veloppement (ou strates) est r√©colt√© pour une p√©riode donn√©e, avec quelle action, et sur quelle surface/zone.\nLe FMTschedule d\u0026rsquo;un FMTlpmodel ou FMTnssmodel solutionn√© peut √™tre r√©cup√©r√© en utilisant leur fonction getsolution(). Cependant, la fonction r√©cup√©rera la solution pour une p√©riode ; vous devrez boucler autour des p√©riodes pour obtenir les solutions pour chaque p√©riode d\u0026rsquo;int√©r√™t, et pour indiquer si vous voulez que la solution prenne en compte les d√©veloppements bloqu√©s (locked).\nFMTsesmodel.Greedyreferencebuild() construira une solution spatialement explicite √† partir d\u0026rsquo;une solution spatialement r√©f√©renc√©e pour une p√©riode donn√©e. Avec le FMTschedule pour la p√©riode, la fonction aura besoin d\u0026rsquo;un argument randomiterations qui est le nombre maximal d\u0026rsquo;it√©rations faites par l\u0026rsquo;algorithme avant qu\u0026rsquo;il ne s\u0026rsquo;arr√™te quand aucune augmentation de la valeur de la fonction d\u0026rsquo;objectif (maximisation de l\u0026rsquo;objectif) ou diminution de la valeur d\u0026rsquo;infaisabilit√© primaire n\u0026rsquo;a √©t√© trouv√©e. Cela s\u0026rsquo;explique par le fait que la simulation est constitu√©e d\u0026rsquo;it√©rations au cours desquelles le mod√®le tente de placer les blocs de coupe dans l\u0026rsquo;espace conform√©ment au calendrier d\u0026rsquo;op√©rations spatialement r√©f√©renc√© afin d\u0026rsquo;augmenter la fonction d\u0026rsquo;objectif du mod√®le (par exemple, le volume r√©colt√©) tout en respectant les contraintes lin√©aires et spatiales donn√©es (dont la d√©viation aux contraintes est repr√©sent√©e par la valeur d\u0026rsquo;infaisabilit√© primaire).\nUne derni√®re entr√©e est un num√©ro de graine al√©atoire (seed) qui sera utilis√© pour g√©n√©rer des nombres al√©atoires utilis√©s pour cr√©er les blocs de coupe √† chaque it√©ration. Ce syst√®me de graine permet √† FMT d\u0026rsquo;utiliser des nombres al√©atoires qui sont \u0026ldquo;r√©plicables\u0026rdquo; ; c\u0026rsquo;est-√†-dire que si vous gardez la m√™me graine, FMT obtiendra les m√™mes nombres al√©atoires, et fera exactement les m√™mes simulations.\nVoici une repr√©sentation du fonctionnement de l\u0026rsquo;algorithme de simulation en pratique :\n  En R, le code pour utiliser FMTsesmodel.Greedyreferencebuild() ressemblera √† ceci :\nlibrary(FMT) # Charge FMT dans R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # V√©rifie si FMT a √©t√© compil√© avec OSI en cr√©ant un nouvel objet FMTversion, et en utilisant la fonction hasfeature().\r{\r# Lit et r√©soud un FMTlpmodel; voir la section sur l'optimisation spatialement r√©f√©renc√©e pour plus de d√©tails\rnewparser \u0026lt;- new(FMTmodelparser)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;Spatial\u0026quot;), TRUE, TRUE, TRUE)\rsolverinterface \u0026lt;- list(CLP=1,MOSEK=2,CPLEX=3,GUROBI=4)\rlpmodel \u0026lt;- new(FMTlpmodel,modelslist[[1]],solverinterface$MOSEK)\remptyschedule \u0026lt;- new(FMTschedule)\rfor (period in 1:10)\r{\rprint(lpmodel$buildperiod(emptyschedule,FALSE,1)$str())\r}\rallmodelconstraints \u0026lt;- lpmodel$getconstraints()\rmodelobjective \u0026lt;- allmodelconstraints[[1]]\rmodelconstraints \u0026lt;- allmodelconstraints[2:length(allmodelconstraints)]\rfor (constraint in modelconstraints)\r{\rprint(lpmodel$setconstraint(constraint)$str())\r}\rprint(lpmodel$setobjective(modelobjective)$str())\r# Ici, on test si le mod√®le a √©t√© r√©solu tout en le r√©solvant, vu que initialsolve() r√©soud le mod√®le et renvoie \u0026quot;true\u0026quot; si il a √©t√© r√©solu\rif (lpmodel$initialsolve())\r{\r# On cr√©er un nouveau mod√®le de simulation spatialement explicite, en se basant sur le contenu de lpmodel\rsimulationmodel \u0026lt;- new(FMTsesmodel, lpmodel)\r# On fait en sorte que les transitions du mod√®le aient une seule sortie, et on les modifient si n√©c√©ssaires\rsingletransition \u0026lt;- list()\rfor (transition in simulationmodel$gettransitions())\r{\r# Le +1 est fait pour s'adapter au fait que FMT √©tant cod√© en C++, il fonctionne en base 0 (les listes commencet √† l'indice 0); alors que R fonctionne en base 1.\rsingletransitions[[length(singletransitions) + 1]] \u0026lt;- transition$single()\r}\rsimulationmodel$settransitions(singletransitions)\r# On pr√©pare un parseur pour lire la carte initiale des for√™ts\rareaparser \u0026lt;- new(FMTareaparser)\r# On d√©finit o√π est-ce que le raster avec les informations initiales des for√™ts se trouvent\rrasterslocation \u0026lt;- \u0026quot;../Models/TWD_land/rasters\u0026quot;\rageraster \u0026lt;- file.path(rasterlocation,\u0026quot;AGE.tif\u0026quot;)\r# On lit les diff√©rents rasters qui contiennent les diff√©rents \u0026quot;themes\u0026quot; (ou attributs) initiaux des for√™ts en faisant\r# une boucle autour de tous les themes d√©finits dans le mod√®le, et en mettant le nom de ces rasters dans une liste\rthemesrasters \u0026lt;- list()\rthemeid \u0026lt;- 1\rfor (theme in simulationmodel$gethemes())\r{\rthemesrasters[[length(themesrasters) + 1]] \u0026lt;- file.path(rasterslocation, paste(\u0026quot;THEME\u0026quot;, paste0(themeID), \u0026quot;.tif\u0026quot;, sep = \u0026quot;\u0026quot;))\rthemeid \u0026lt;- themeid + 1\r}\r# Maintenant que l'on a tous les rasters, on creer un object FMTforest en lisant tous les rasters de themes, qui contiennent les informations initiales des for√™ts\rinitialforestmap \u0026lt;- areaparser$readrasters(simulationmodel$getthemes(), unlist(themerasters), ageraster, 1, 0.0001, \u0026quot;\u0026quot;)\r# On donne les donn√©es initiales de for√™t au mod√®le spatialement explicite\rsimulationmodel$setinitialmapping(initialforestmap)\r# Maintenant, on trouve la solution spatialement explicite pour chaque p√©riode de temps,\r# en se basant sur la solution du lpmodel pour cette p√©riode.\r# On stoppera la recherche de l'algorithme lorsqu'il n'aura pas trouv√© de meilleurs placements pour augmenter la fonction objectif\r# ou bien r√©duire l'infasibilit√© primaire pendant 10 it√©rations.\rfor (period in 1:10)\r{\rprint(simulationmodel$greedyreferencebuild(lpmodel$getsolution(period,FALSE), 10, 0, 0.0001))\r}\r}\r} else { # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\r L\u0026rsquo;√©quivalent en Python est :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Lit et r√©soud un FMTlpmodel; voir la section sur l'optimisation spatialement r√©f√©renc√©e pour plus de d√©tails\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;Spatial\u0026quot;]\rmodelslist = newmodelparser.readproject(path, scenarios)\rlpmodel = Models.FMTlpmodel(modelslist[0], Models.FMTsolverinterface.CLP)\rfor period in range(1, 11):\rprint(lpmodel.buildperiod())\rconstraints = lpmodel.getconstraints()\robjective = constraints.pop(0)\rfor constraint in constraints:\rlpmodel.setconstraint(constraint)\rlpmodel.setobjective(objective)\r# Ici, on test si le mod√®le a √©t√© r√©solu tout en le r√©solvant, vu que initialsolve() r√©soud le mod√®le et renvoie \u0026quot;true\u0026quot; si il a √©t√© r√©solu\rif lpmodel.initialsolve():\r# On cr√©er un nouveau mod√®le de simulation spatialement explicite, en se basant sur le contenu de lpmodel\rsimulationmodel = Models.FMTsesmodel(lpmodel)\r# On fait en sorte que les transitions du mod√®le aient une seule sortie, et on les modifient si n√©c√©ssaires\rsingletransitions = []\rfor transition in simulationmodel.gettransitions():\rsingletransitions.append(transition.single())\rsimulationmodel.settransitions(singletransitions)\r# On pr√©pare un parseur pour lire la carte initiale des for√™ts\rareaparser = Parser.FMTareaparser()\r# On d√©finit o√π est-ce que le raster avec les informations initiales des for√™ts se trouvent\rrasterslocation = \u0026quot;../Models/TWD_land/rasters/\u0026quot;\rageraster = os.path.join(rasterslocation, \u0026quot;AGE.tif\u0026quot;)\r# On lit les diff√©rents rasters qui contiennent les diff√©rents \u0026quot;themes\u0026quot; (ou attributs) initiaux des for√™ts en faisant\r# une boucle autour de tous les themes d√©finits dans le mod√®le, et en mettant le nom de ces rasters dans une liste\rthemesrasters = []\rthemeid = 1\rfor theme in simulationmodel.getthemes():\rthemesrasters.append(os.path.join(rasterslocation, \u0026quot;THEME\u0026quot; + str(themeid) + \u0026quot;.tif\u0026quot;))\rthemeid += 1\r# Maintenant que l'on a tous les rasters, on creer un object FMTforest en lisant tous les rasters de themes, qui contiennent les informations initiales des for√™ts\rinitialforestmap = areaparser.readrasters(simulationmodel.getthemes(), themesrasters, ageraster, 1, 0.0001)\r# On donne les donn√©es initiales de for√™t au mod√®le spatialement explicite\rsimulationmodel.setinitialmapping(initialforestmap)\r# Maintenant, on trouve la solution spatialement explicite pour chaque p√©riode de temps,\r# en se basant sur la solution du lpmodel pour cette p√©riode.\r# On stoppera la recherche de l'algorithme lorsqu'il n'aura pas trouv√© de meilleurs placements pour augmenter la fonction objectif\r# ou bien r√©duire l'infasibilit√© primaire pendant 10 it√©rations.\rfor period in range(1, 11):\rprint(simulationmodel.greedyreferencebuild(lpmodel.getsolution(period), 10))\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;) # Si le mod√®le n'as pas √©t√© compil√© avec OSI, on affiche une erreur\r La sortie des deux codes devrait √™tre la suivante. Il y a beaucoup de choses √† traiter, mais nous les examinerons plus pr√©cis√©ment dans la prochaine section :\nReading D:/TempCode/FMT/FMT/Examples/Models/TWD_land/TWD_Land.pri FMT 0.9.1, build: Oct 22 2021 11:52:53\rFri Feb 18 12:44:56 2022\rReading scenario Spatial\rFMTexc(41)Ignoring: YBM_RTM_MEH at line 44 FMTsection(6)Yield\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rDone reading Fri Feb 18 12:44:56 2022\rColumns: 69 Rows: 34 Vertices: 62 Edges: 69 Transfer Rows: 34 Output Rows: 0 Output Columns: 0\rColumns: 173 Rows: 86 Vertices: 126 Edges: 173 Transfer Rows: 86 Output Rows: 0 Output Columns: 0\rColumns: 320 Rows: 156 Vertices: 208 Edges: 320 Transfer Rows: 156 Output Rows: 0 Output Columns: 0\rColumns: 510 Rows: 244 Vertices: 308 Edges: 510 Transfer Rows: 244 Output Rows: 0 Output Columns: 0\rColumns: 730 Rows: 350 Vertices: 426 Edges: 730 Transfer Rows: 350 Output Rows: 0 Output Columns: 0\rColumns: 986 Rows: 474 Vertices: 562 Edges: 986 Transfer Rows: 474 Output Rows: 0 Output Columns: 0\rColumns: 1278 Rows: 616 Vertices: 716 Edges: 1278 Transfer Rows: 616 Output Rows: 0 Output Columns: 0\rColumns: 1606 Rows: 776 Vertices: 888 Edges: 1606 Transfer Rows: 776 Output Rows: 0 Output Columns: 0\rColumns: 1992 Rows: 964 Vertices: 1088 Edges: 1992 Transfer Rows: 964 Output Rows: 0 Output Columns: 0\rColumns: 2436 Rows: 1180 Vertices: 1316 Edges: 2436 Transfer Rows: 1180 Output Rows: 0 Output Columns: 0\rCoin0506I Presolve 76 (-1143) rows, 226 (-2211) columns and 898 (-5379) elements\rClp0035I 0 Primal 100 Dual 842632.63 Complementarity 842579 - 0 fixed, rank 76\rClp0035I 1 Primal 225.4735 Dual 307283.38 Complementarity 318751.96 - 0 fixed, rank 76\rClp0035I 2 Primal 7266.7264 Dual 146511.3 Complementarity 174120.63 - 0 fixed, rank 76\rClp0035I 3 Primal 35053.074 Dual 105622.03 Complementarity 73089.174 - 0 fixed, rank 76\rClp0035I 4 Primal 38320.846 Dual 70235.705 Complementarity 33405.695 - 0 fixed, rank 76\rClp0035I 5 Primal 44403.19 Dual 55792.68 Complementarity 11676.178 - 0 fixed, rank 76\rClp0035I 6 Primal 46801.335 Dual 50712.255 Complementarity 3964.085 - 0 fixed, rank 76\rClp0035I 7 Primal 47534.239 Dual 48865.81 Complementarity 1331.5805 - 0 fixed, rank 76\rClp0035I 8 Primal 47849.045 Dual 48152.188 Complementarity 303.14539 - 0 fixed, rank 76\rClp0035I 9 Primal 47959.375 Dual 48049.655 Complementarity 90.456075 - 0 fixed, rank 76\rClp0035I 10 Primal 47999.651 Dual 48009.843 Complementarity 10.204147 - 0 fixed, rank 76\rClp0035I 11 Primal 47998.773 Dual 48000.252 Complementarity 1.4873248 - 0 fixed, rank 76\rClp0035I 12 Primal 47999.994 Dual 48000.002 Complementarity 0.0085757189 - 0 fixed, rank 76\rClp0035I 13 Primal 48000 Dual 48000 Complementarity 0.00011127406 - 0 fixed, rank 70\rClp0035I 14 Primal 48000 Dual 48000 Complementarity 1.102542e-06 - 0 fixed, rank 63\rClp0035I 15 Primal 48000 Dual 48000.074 Complementarity 8.4407744e-09 - 20 fixed, rank 68\rClp0035I 16 Primal 48000 Dual 48000 Complementarity 6.8286544e-11 - 20 fixed, rank 65\rClp0042I Optimal\rClp0046I At end primal/dual infeasibilities 0.00015298276/0.10009623, complementarity gap 4.668539e-06, objective 48000\rClp0006I 0 Obj 48000 Dual inf 0.015282 (8)\rClp0006I 152 Obj 48000\rClp0000I Optimal - objective value 48000\rClp0006I 0 Obj 48000\rClp0000I Optimal - objective value 48000\rClp0006I 0 Obj 48000\rClp0000I Optimal - objective value 48000\rCoin0511I After Postsolve, objective 48000, infeasibilities - dual 0 (0), primal 0 (0)\rClp0032I Optimal objective 48000 - 16 iterations time 0.022, Presolve 0.01\rIteration 0 Primal Inf(0.000000) Obj(40475.320000)\rIteration 10 Primal Inf(0.000000) Obj(44085.320000)\rStalled after 16 iterations Skipping\r{'ACARIBOU': 0.981677543988014, 'COUPETOTALE': 0.9817026645791909, 'Objective': 42453.599999999984, 'Primalinfeasibility': 0.0, 'Total': 0.9816850800303768}\rIteration 0 Primal Inf(2310.400000) Obj(40143.200000)\rIteration 10 Primal Inf(216.600000) Obj(42237.000000)\rIteration 20 Primal Inf(0.000000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 1.0278470194296387, 'COUPETOTALE': 0.9116104392588846, 'Objective': 42453.599999999984, 'PLANTATION': 0.927291117344956, 'Primalinfeasibility': 1.4551915228366852e-11, 'Total': 0.9264994202031354}\rIteration 0 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 10 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 20 Primal Inf(635.360000) Obj(42453.600000)\rSolution stuck after 27 iterations Skipping\r{'ACARIBOU': 0.8973831819756647, 'COUPETOTALE': 0.9033560325101042, 'Objective': 42453.599999999984, 'PLANTATION': 0.911737449703183, 'Primalinfeasibility': 635.3600000000297, 'Total': 0.9025186555019942}\rIteration 0 Primal Inf(8779.520000) Obj(42453.600000)\rIteration 10 Primal Inf(8779.520000) Obj(42453.600000)\rIteration 20 Primal Inf(808.640000) Obj(42453.600000)\rSolution stuck after 29 iterations Skipping\r{'ACARIBOU': 0.8771528754492212, 'COUPETOTALE': 0.889988896215573, 'Objective': 42453.599999999984, 'PLANTATION': 0.8765659747164727, 'Primalinfeasibility': 808.6400000000212, 'Total': 0.8822416209150494}\rIteration 0 Primal Inf(6931.200000) Obj(42453.600000)\rIteration 10 Primal Inf(6931.200000) Obj(42453.600000)\rIteration 20 Primal Inf(1111.880000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 0.8952525436304627, 'COUPETOTALE': 0.88445, 'Objective': 42453.599999999984, 'PLANTATION': 0.9411700993142432, 'Primalinfeasibility': 1111.8800000000338, 'Total': 0.9032996680762417}\rIteration 0 Primal Inf(9342.680000) Obj(42453.600000)\rIteration 10 Primal Inf(3638.880000) Obj(42453.600000)\rIteration 20 Primal Inf(3638.880000) Obj(42453.600000)\rIteration 30 Primal Inf(3638.880000) Obj(42453.600000)\rSolution stuck after 35 iterations Skipping\r{'ACARIBOU': 968.4932690882329, 'COUPETOTALE': 0.9397466289394396, 'Objective': 42453.599999999984, 'PLANTATION': 2367.8747068875177, 'Primalinfeasibility': 3638.8800000000047, 'Total': 1.0649491134961293}\rIteration 0 Primal Inf(16606.000000) Obj(30309.560000)\rStalled after 9 iterations Skipping\r{'ACARIBOU': 1.3474601235578203, 'COUPETOTALE': 0.9825519488602954, 'Objective': 32937.64000000001, 'PLANTATION': 1.0022853728788734, 'Primalinfeasibility': 13977.919999999998, 'Total': 1.0087375080393326}\rIteration 0 Primal Inf(119576.200000) Obj(32937.640000)\rIteration 10 Primal Inf(65859.400000) Obj(32937.640000)\rIteration 20 Primal Inf(39247.920000) Obj(32937.640000)\rSolution stuck after 28 iterations Skipping\r{'ACARIBOU': 1054.0980891170655, 'COUPETOTALE': 0.845845565618348, 'Objective': 32937.64000000001, 'PLANTATION': 0.9266686936638757, 'Primalinfeasibility': 39247.9200000001, 'Total': 0.8969889215263215}\rIteration 0 Primal Inf(58611.960000) Obj(27522.640000)\rStalled after 6 iterations Skipping\r{'ACARIBOU': 536.8311084909311, 'COUPETOTALE': 0.4341194959208162, 'Objective': 27667.040000000005, 'PLANTATION': 0.9541653732993195, 'Primalinfeasibility': 58467.560000000114, 'Total': 0.7846327502399465}\rIteration 0 Primal Inf(79145.640000) Obj(26208.600000)\rIteration 10 Primal Inf(77340.640000) Obj(27667.040000)\rStalled after 14 iterations Skipping\r{'ACARIBOU': 10491.125109295706, 'COUPETOTALE': 0.3982872281191633, 'Objective': 27667.040000000005, 'PLANTATION': 1.0028031096555103, 'Primalinfeasibility': 77340.64000000012, 'Total': 0.8163283360740083}\r Analyser les sorties de FMTsesmodel.Greedyreferencebuild() FMTsesmodel.Greedyreferencebuild() retourne des informations sur la meilleure solution qui a √©t√© trouv√©e ; c\u0026rsquo;est-√†-dire le meilleur placement spatial des blocs de coupe que l\u0026rsquo;algorithme a √©t√© capable de trouver en optimisant la fonction d\u0026rsquo;objectif, tout en respectant les contraintes lin√©aires et spatiales qui ont √©t√© donn√©es par l\u0026rsquo;utilisateur.\nEn particulier, FMTsesmodel.Greedyreferencebuild() indique 4 informations importantes :\n   Mot Description     Objective Valeur de la fonction d\u0026rsquo;objectif de la solution spatialement explicite.   Primalinfeasibilities Valeur d\u0026rsquo;infaisabilit√© primaire de la solution spatialement explicite, par rapport aux contraintes qui ont √©t√© donn√©es. Une valeur proche de 0 signifie que la solution est 100% faisable selon les contraintes lin√©aires et spatiales.   Total Proportion totale de la zone de la planification spatialement r√©f√©renc√©e pass√©e en entr√©e qui a √©t√© spatialis√©e avec succ√®s par l\u0026rsquo;algorithme.   Actionname x Proportion de la zone spatialis√©e d\u0026rsquo;une action donn√©e x de la solution originale spatialement r√©f√©renc√©e pass√©e √† la fonction.    Maintenant, examinons les r√©sultats de la section pr√©c√©dente pour essayer de comprendre ce qui s\u0026rsquo;est pass√©.\nTout d\u0026rsquo;abord, nous voyons les m√™mes sorties habituelles qui indiquent que FMT lit, puis r√©sout le mod√®le en utilisant le solveur CLP :\nReading D:/TempCode/FMT/FMT/Examples/Models/TWD_land/TWD_Land.pri FMT 0.9.1, build: Oct 22 2021 11:52:53\rFri Feb 18 12:44:56 2022\rReading scenario Spatial\rFMTexc(41)Ignoring: YBM_RTM_MEH at line 44 FMTsection(6)Yield\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rDone reading Fri Feb 18 12:44:56 2022\rColumns: 69 Rows: 34 Vertices: 62 Edges: 69 Transfer Rows: 34 Output Rows: 0 Output Columns: 0\rColumns: 173 Rows: 86 Vertices: 126 Edges: 173 Transfer Rows: 86 Output Rows: 0 Output Columns: 0\rColumns: 320 Rows: 156 Vertices: 208 Edges: 320 Transfer Rows: 156 Output Rows: 0 Output Columns: 0\rColumns: 510 Rows: 244 Vertices: 308 Edges: 510 Transfer Rows: 244 Output Rows: 0 Output Columns: 0\rColumns: 730 Rows: 350 Vertices: 426 Edges: 730 Transfer Rows: 350 Output Rows: 0 Output Columns: 0\rColumns: 986 Rows: 474 Vertices: 562 Edges: 986 Transfer Rows: 474 Output Rows: 0 Output Columns: 0\rColumns: 1278 Rows: 616 Vertices: 716 Edges: 1278 Transfer Rows: 616 Output Rows: 0 Output Columns: 0\rColumns: 1606 Rows: 776 Vertices: 888 Edges: 1606 Transfer Rows: 776 Output Rows: 0 Output Columns: 0\rColumns: 1992 Rows: 964 Vertices: 1088 Edges: 1992 Transfer Rows: 964 Output Rows: 0 Output Columns: 0\rColumns: 2436 Rows: 1180 Vertices: 1316 Edges: 2436 Transfer Rows: 1180 Output Rows: 0 Output Columns: 0\rCoin0506I Presolve 76 (-1143) rows, 226 (-2211) columns and 898 (-5379) elements\rClp0035I 0 Primal 100 Dual 842632.63 Complementarity 842579 - 0 fixed, rank 76\rClp0035I 1 Primal 225.4735 Dual 307283.38 Complementarity 318751.96 - 0 fixed, rank 76\rClp0035I 2 Primal 7266.7264 Dual 146511.3 Complementarity 174120.63 - 0 fixed, rank 76\rClp0035I 3 Primal 35053.074 Dual 105622.03 Complementarity 73089.174 - 0 fixed, rank 76\rClp0035I 4 Primal 38320.846 Dual 70235.705 Complementarity 33405.695 - 0 fixed, rank 76\rClp0035I 5 Primal 44403.19 Dual 55792.68 Complementarity 11676.178 - 0 fixed, rank 76\rClp0035I 6 Primal 46801.335 Dual 50712.255 Complementarity 3964.085 - 0 fixed, rank 76\rClp0035I 7 Primal 47534.239 Dual 48865.81 Complementarity 1331.5805 - 0 fixed, rank 76\rClp0035I 8 Primal 47849.045 Dual 48152.188 Complementarity 303.14539 - 0 fixed, rank 76\rClp0035I 9 Primal 47959.375 Dual 48049.655 Complementarity 90.456075 - 0 fixed, rank 76\rClp0035I 10 Primal 47999.651 Dual 48009.843 Complementarity 10.204147 - 0 fixed, rank 76\rClp0035I 11 Primal 47998.773 Dual 48000.252 Complementarity 1.4873248 - 0 fixed, rank 76\rClp0035I 12 Primal 47999.994 Dual 48000.002 Complementarity 0.0085757189 - 0 fixed, rank 76\rClp0035I 13 Primal 48000 Dual 48000 Complementarity 0.00011127406 - 0 fixed, rank 70\rClp0035I 14 Primal 48000 Dual 48000 Complementarity 1.102542e-06 - 0 fixed, rank 63\rClp0035I 15 Primal 48000 Dual 48000.074 Complementarity 8.4407744e-09 - 20 fixed, rank 68\rClp0035I 16 Primal 48000 Dual 48000 Complementarity 6.8286544e-11 - 20 fixed, rank 65\rClp0042I Optimal\rClp0046I At end primal/dual infeasibilities 0.00015298276/0.10009623, complementarity gap 4.668539e-06, objective 48000\rClp0006I 0 Obj 48000 Dual inf 0.015282 (8)\rClp0006I 152 Obj 48000\rClp0000I Optimal - objective value 48000\rClp0006I 0 Obj 48000\rClp0000I Optimal - objective value 48000\rClp0006I 0 Obj 48000\rClp0000I Optimal - objective value 48000\rCoin0511I After Postsolve, objective 48000, infeasibilities - dual 0 (0), primal 0 (0)\rClp0032I Optimal objective 48000 - 16 iterations time 0.022, Presolve 0.01\r Ensuite, nous pouvons voir les lignes qui correspondent aux simulations de la fonction FMTsesmodel.Greedyreferencebuild() :\nIteration 0 Primal Inf(0.000000) Obj(40475.320000)\rIteration 10 Primal Inf(0.000000) Obj(44085.320000)\rStalled after 16 iterations Skipping\r{'ACARIBOU': 0.981677543988014, 'COUPETOTALE': 0.9817026645791909, 'Objective': 42453.599999999984, 'Primalinfeasibility': 0.0, 'Total': 0.9816850800303768}\rIteration 0 Primal Inf(2310.400000) Obj(40143.200000)\rIteration 10 Primal Inf(216.600000) Obj(42237.000000)\rIteration 20 Primal Inf(0.000000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 1.0278470194296387, 'COUPETOTALE': 0.9116104392588846, 'Objective': 42453.599999999984, 'PLANTATION': 0.927291117344956, 'Primalinfeasibility': 1.4551915228366852e-11, 'Total': 0.9264994202031354}\rIteration 0 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 10 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 20 Primal Inf(635.360000) Obj(42453.600000)\rSolution stuck after 27 iterations Skipping\r{'ACARIBOU': 0.8973831819756647, 'COUPETOTALE': 0.9033560325101042, 'Objective': 42453.599999999984, 'PLANTATION': 0.911737449703183, 'Primalinfeasibility': 635.3600000000297, 'Total': 0.9025186555019942}\rIteration 0 Primal Inf(8779.520000) Obj(42453.600000)\rIteration 10 Primal Inf(8779.520000) Obj(42453.600000)\rIteration 20 Primal Inf(808.640000) Obj(42453.600000)\rSolution stuck after 29 iterations Skipping\r{'ACARIBOU': 0.8771528754492212, 'COUPETOTALE': 0.889988896215573, 'Objective': 42453.599999999984, 'PLANTATION': 0.8765659747164727, 'Primalinfeasibility': 808.6400000000212, 'Total': 0.8822416209150494}\rIteration 0 Primal Inf(6931.200000) Obj(42453.600000)\rIteration 10 Primal Inf(6931.200000) Obj(42453.600000)\rIteration 20 Primal Inf(1111.880000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 0.8952525436304627, 'COUPETOTALE': 0.88445, 'Objective': 42453.599999999984, 'PLANTATION': 0.9411700993142432, 'Primalinfeasibility': 1111.8800000000338, 'Total': 0.9032996680762417}\rIteration 0 Primal Inf(9342.680000) Obj(42453.600000)\rIteration 10 Primal Inf(3638.880000) Obj(42453.600000)\rIteration 20 Primal Inf(3638.880000) Obj(42453.600000)\rIteration 30 Primal Inf(3638.880000) Obj(42453.600000)\rSolution stuck after 35 iterations Skipping\r{'ACARIBOU': 968.4932690882329, 'COUPETOTALE': 0.9397466289394396, 'Objective': 42453.599999999984, 'PLANTATION': 2367.8747068875177, 'Primalinfeasibility': 3638.8800000000047, 'Total': 1.0649491134961293}\rIteration 0 Primal Inf(16606.000000) Obj(30309.560000)\rStalled after 9 iterations Skipping\r{'ACARIBOU': 1.3474601235578203, 'COUPETOTALE': 0.9825519488602954, 'Objective': 32937.64000000001, 'PLANTATION': 1.0022853728788734, 'Primalinfeasibility': 13977.919999999998, 'Total': 1.0087375080393326}\rIteration 0 Primal Inf(119576.200000) Obj(32937.640000)\rIteration 10 Primal Inf(65859.400000) Obj(32937.640000)\rIteration 20 Primal Inf(39247.920000) Obj(32937.640000)\rSolution stuck after 28 iterations Skipping\r{'ACARIBOU': 1054.0980891170655, 'COUPETOTALE': 0.845845565618348, 'Objective': 32937.64000000001, 'PLANTATION': 0.9266686936638757, 'Primalinfeasibility': 39247.9200000001, 'Total': 0.8969889215263215}\rIteration 0 Primal Inf(58611.960000) Obj(27522.640000)\rStalled after 6 iterations Skipping\r{'ACARIBOU': 536.8311084909311, 'COUPETOTALE': 0.4341194959208162, 'Objective': 27667.040000000005, 'PLANTATION': 0.9541653732993195, 'Primalinfeasibility': 58467.560000000114, 'Total': 0.7846327502399465}\rIteration 0 Primal Inf(79145.640000) Obj(26208.600000)\rIteration 10 Primal Inf(77340.640000) Obj(27667.040000)\rStalled after 14 iterations Skipping\r{'ACARIBOU': 10491.125109295706, 'COUPETOTALE': 0.3982872281191633, 'Objective': 27667.040000000005, 'PLANTATION': 1.0028031096555103, 'Primalinfeasibility': 77340.64000000012, 'Total': 0.8163283360740083}\r Cette premi√®re ligne nous informe sur la premi√®re solution trouv√©e par la simulation : dans cette solution, la valeur d\u0026rsquo;infaisabilit√© primaire est 0, ce qui signifie que la solution est 100% faisable, et que les contraintes lin√©aires et spatiales que nous avons mises sont toujours respect√©es. Cependant, nous pouvons voir que la valeur de la fonction objectif est inf√©rieure √† celle trouv√©e par la r√©solution du mod√®le spatialement r√©f√©renc√© (qui √©tait 48000).\nIteration 0 Primal Inf(0.000000) Obj(40475.320000)\r Apr√®s 10 solutions g√©n√©r√©es, nous pouvons voir que l\u0026rsquo;infaisabilit√© primaire est toujours 0, et que la valeur de la fonction objectif a augment√© √† 448085.32.\nIteration 10 Primal Inf(0.000000) Obj(44085.320000)\r Ensuite, FMT termine les simulations de la premi√®re p√©riode en nous indiquant pourquoi il a arr√™t√© de chercher, et la proportion de chaque action qu\u0026rsquo;il a pu placer dans l\u0026rsquo;espace.\nIci, pour la premi√®re p√©riode, FMT a arr√™t√© la recherche en indiquant que l\u0026rsquo;algorithme s\u0026rsquo;est stabilis√© (stalled). Pendant ce temps, il a √©t√© capable de spatialiser 98% de l\u0026rsquo;action ACARIBOU, et 98% de l\u0026rsquo;action COUPETOTALE.\nStalled after 16 iterations Skipping\r{'ACARIBOU': 0.981677543988014, 'COUPETOTALE': 0.9817026645791909, 'Objective': 42453.599999999984, 'Primalinfeasibility': 0.0, 'Total': 0.9816850800303768}\r Le processus se r√©p√®te ensuite pour les 9 autres p√©riodes. A chaque fois, le FMT commence par une premi√®re it√©ration de placement des actions dans l\u0026rsquo;espace en essayant de respecter les contraintes. Ensuite, l\u0026rsquo;algorithme se termine lorsqu\u0026rsquo;il est soit stalled (stabilis√©), soit stuck (bloqu√©), ce qui signifie qu\u0026rsquo;il ne peut plus am√©liorer la solution ou r√©duire l\u0026rsquo;infaisabilit√© primale. Il affiche alors le nombre d\u0026rsquo;actions qu\u0026rsquo;il a pu placer dans l\u0026rsquo;espace.\nNotez que stalled et stuck ont deux significations diff√©rentes :\n Stalled signifie que l\u0026rsquo;algorithme a g√©n√©r√© exactement les m√™mes solutions (le m√™me placement des coupes dans l\u0026rsquo;espace) que ses 3 derni√®res it√©rations, ce qui implique qu\u0026rsquo;il ne peut g√©n√©rer aucune nouvelle solution. Cela peut se produire lorsque les contraintes font que le nombre de solutions potentielles est limit√©, ce qui signifie que l\u0026rsquo;algorithme les aura rapidement toutes essay√©es. Stuck signifie que l\u0026rsquo;algorithme a pu g√©n√©rer diff√©rentes solutions, mais que toutes ces nouvelles solutions ont une valeur de fonction d\u0026rsquo;objectif qui n\u0026rsquo;est pas sup√©rieure aux pr√©c√©dentes, ou bien que ces nouvelles solutions ne peuvent pas r√©duire l\u0026rsquo;infaisabilit√© primaire. Apr√®s un nombre d\u0026rsquo;it√©rations correspondant aux arguments randomiterations fournis √† FMTsesmodel.Greedyreferencebuild() sans aucune am√©lioration, l\u0026rsquo;algorithme s\u0026rsquo;arr√™te.  Pour la deuxi√®me p√©riode, nous pouvons voir :\nIteration 0 Primal Inf(2310.400000) Obj(40143.200000)\rIteration 10 Primal Inf(216.600000) Obj(42237.000000)\rIteration 20 Primal Inf(0.000000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 1.0278470194296387, 'COUPETOTALE': 0.9116104392588846, 'Objective': 42453.599999999984, 'PLANTATION': 0.927291117344956, 'Primalinfeasibility': 1.4551915228366852e-11, 'Total': 0.9264994202031354}\r Pour la troisi√®me p√©riode, nous pouvons voir :\nIteration 0 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 10 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 20 Primal Inf(635.360000) Obj(42453.600000)\rSolution stuck after 27 iterations Skipping\r{'ACARIBOU': 0.8973831819756647, 'COUPETOTALE': 0.9033560325101042, 'Objective': 42453.599999999984, 'PLANTATION': 0.911737449703183, 'Primalinfeasibility': 635.3600000000297, 'Total': 0.9025186555019942}\r Et ainsi de suite jusqu\u0026rsquo;√† la 10√®me p√©riode.\n Vous devriez maintenant en savoir assez pour commencer √† utiliser le FMT par vous-m√™me. Si vous avez d\u0026rsquo;autres questions, veuillez contacter Guillaume Cyr ou Bruno Forest du BFEC. Vous pouvez √©galement installer FMT sur votre ordinateur en suivant la section T√©l√©chargement et installation.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"fr","lastmod":1557010800,"objectID":"793eb7f10f8d83f2a8f6adcc3e722198","permalink":"https://bureau-du-forestier-en-chef.github.io/FMT/fr/docs/basics/spatially_explicit_simulation/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/FMT/fr/docs/basics/spatially_explicit_simulation/","section":"docs","summary":"Un petit rappel sur la signification de \u0026ldquo;spatialement r√©f√©renc√©\u0026rdquo;. On peut distinguer 3 fa√ßons de prendre en compte l\u0026rsquo;espace dans un mod√®le :\n Dans un mod√®le non spatial ou mod√®le spatialement implicite, les entit√©s (par exemple, les for√™ts, les animaux, les agents, etc.","tags":null,"title":"Simulation spatiallement explicite","type":"book"}]