[{"authors":null,"categories":null,"content":"What is FMT ? In its most basic form, FMT is an open-source library of functions and objects that you can use in different programming langages : C++, R or Python.\nThe functions and objects of FMT are used to do forest planning. Forest planning answers the question of how a forested landscape should be treated in order to maximize certain objectives (e.g. economic return), under certain constraints (e.g. ecological and conservation objectives, legislation, operational limitations, etc.).\nConcretely, FMT allows you to :\n Read forest planning models based on the Woodstock file format (which are spatially referenced type III linear programming models) Edit and tweak those forest planning models Solve those forest planning models (i.e. generate a schedule of actions which maximize objectives and respect constraints) Make the stand variables and optimized schedule spatially explicit (i.e. mapping the forest operations on a map)  What is it mainly used for ?  Reading Woodstock models Simulating forests landscapes Optimizing/Re-optimizing the models Replanning (by using stochastic events) Resolving aggregation heuristics Plannification of harvest blocs  How does it work technically ? The source code of the functions in FMT is written in the C++ langage.\nHowever, it is made to be compiled into different libraries format that can be used in the Python and R langage.\ngraph TD;\r1--\u0026gt;2;\r1--\u0026gt;3;\r1--\u0026gt;4;\r1[\u0026quot;Programing interface (C++)\u0026quot;]\r2[\u0026quot;Python 2\u0026quot;]\r3[\u0026quot;Python 3\u0026quot;]\r4[\u0026quot;Cran R\u0026quot;]\r Why was it made ? The FMT project started in 2017, at the Chief forester\u0026rsquo;s office (BFEC) of QuÃ©bec.\nBecause the BFEC used Woodstock models every day, there was a need to have replicable code allowing users to automatically read and edit Woodstock models files without using the graphical interface of Woodstock every time.\nIn 2018, the BFEC started to be interested in having a tool to quantify carbon stocks in the forests. The choosen tool (GCBM) made precise estimates of carbon stocks and fluxes, but it needed information about where and when cuts would be made in the forest landscape, according to different managed scenarios.\nBecause of this, a model was needed to transform the spatially referenced information of Woodstock models (which groups all forest of the same types accross the landscape) into spatially explicit information (which contains information for every precise location on a map).\nFrom 2019 to today, many features were made to improve the performance of FMT, and its capacity to make re-plannification.\nWhat are the futur plans for FMT ?  A user interface for certain functions usefull for BFEC analysts, and for its integration with GCBM Spatially explicit optimization (currently, the optimization is done at the spatially referenced level, and its results are then made spatially explicit with heuristics) Better outputs to facilitate integration with other models or scripts   Now that you know so much about FMT, you\u0026rsquo;ll have no trouble understanding how it works, and how to use it.\n FMT uses a model structure and inputs that are very similar to the Woodstock software by Remsoft.\nIf you don\u0026rsquo;t know anything about Woodstock models, you should take some time to read about them before reading this documentation. You\u0026rsquo;ll feel a bit lost if you don\u0026rsquo;t.\n  Ready to start ?\n ðŸ“– Start reading   ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"04db5c02e6f257acc19ec89db5919756","permalink":"/docs/basics/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/docs/basics/","section":"docs","summary":"Learn what FMT is, and what it does.","tags":null,"title":"The basics","type":"book"},{"authors":null,"categories":null,"content":"FMT is a program that requires to be compiled on your computer so that it can be executed.\nDon\u0026rsquo;t worry; it\u0026rsquo;s not as complex as it seems !\nWhat is compilation ? Compilation is a step where your computer will transform the source code (which are files that you, a human, can read) of the program into a set of binaries (which are files that your computer can read).\n You use binaries every day, without even thinking about it; for example, a .exe file on Windows is a binary. If you open it with the Windows notepad, you will not be able to understand its content, but your computer can.   What is needed to compile ? To compile FMT, your computer will need :\n The source code of FMT All of the libraries of functions that FMT use A compiler  The documentation will guide you for all of these steps.\n Preparing everything takes around half an hour, but the download and compiling takes about 6 hours (but you don\u0026rsquo;t need to do anything while your computer does it).    Currently, this documentation for compiling FMT only covers installing FMT for Windows 8-10, and for use under Python.\nIf you\u0026rsquo;re a Mac or Linux user, or if you want to use FMT in R, please warn us in the issue section of the FMT repository.\n  Ready to start ?\n ðŸ’¾ Start the process   ","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"cb3f7061761e7263b0c7801f991613a2","permalink":"/docs/download_install/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/docs/download_install/","section":"docs","summary":"Learn how download and install FMT on your computer.","tags":null,"title":"Downloading and installing","type":"book"},{"authors":null,"categories":null,"content":"Welcome to the FMT documentation !\n Before you start reading, know that you can change the appearance of the documentation (light or dark theme) using the little moon or sun icon at the top-right corner of the screen.    FMT uses a model structure and inputs that are very similar to the Woodstock software by Remsoft.\nIf you don\u0026rsquo;t know anything about Woodstock models, you should take some time to read about them before reading this documentation. You\u0026rsquo;ll feel a bit lost if you don\u0026rsquo;t.\n  If you want to better understand what is FMT and what it does, you can starts with the basics :\n âœ¨ Discovering the basics of FMT   If you want to install FMT, take a look at the installation instructions :\n ðŸ’¾ Downloading and installing FMT   Else, you can use the search bar or the table of contents on the left to find what you seek.\nHappy reading !\n","date":1557010800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1557010800,"objectID":"4cdd37113783e47641dd300543c94e1b","permalink":"/docs/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/docs/","section":"docs","summary":"Welcome to the FMT documentation !\n Before you start reading, know that you can change the appearance of the documentation (light or dark theme) using the little moon or sun icon at the top-right corner of the screen.","tags":null,"title":"FMT Documentation","type":"book"},{"authors":null,"categories":null,"content":"What are objects ? FMT is made with a particular structure that is called Object-Oriented Programming (OOP). If you never heard of it, here is a very quick summary of it to better understand how to use FMT later.\nIn the OOP approach, the program use different \u0026ldquo;objects\u0026rdquo; that have a certain \u0026ldquo;class\u0026rdquo;, and that can have different \u0026ldquo;functions\u0026rdquo;.\nYou might already know and use functions in software such as R. For example, in R, plot() is a function.\nYou might also be used to some objects and classes being called in software you use. For example, in R, data \u0026lt;- read.csv(data.csv) puts the content of the data.csv file into the data object, which has the class data frame.\nNow, imagine that every function that you use are associated to an object of a particular class. For example, a class dog would have the function bark_at(). If we have a class named cat, we could then :\n Create a new dog object from the dog class : pluto = dog(name = Pluto, age = 8) Create a new cat object from the cat class : felix = cat(name = Felix, age = 2) Make the dog bark at the cat : pluto.bark_at(felix)  In turn, object can have \u0026ldquo;properties\u0026rdquo;, which are exactly what it sounds like. For example, let say that our cat class has three properties : name (which can be a string of characters), age (which can be a number), and scared (which is a boolean, true or false).\nIn our previous example, before using pluto.bark_at(felix), the property felix.scared could be false. But now that we used pluto.bark_at(felix), felix.scared might have changed to true.\nLastly, a parent class in Object Oriented Programming means that the child class will automatically inherit all of the functions and properties of the parent function.\nFor example, let\u0026rsquo;s suppose that we have a animal parent class from which the dog and cat classes derive. If the animal class has a function breathing (animal.breathing()), then the dog and cat classes being its child classes will automatically have this function (dog.breathing() and cat.breathing()).\nObject-Oriented Programming is a particular way to program, embedded in the programming language that you use, that have multiple advantages. One of them is to make things easier to represent.\nIn short : FMT uses Object-Oriented Programming, which makes everything an object with particular functions. The functions and properties of an object are defined by its class.\nTo learn to use FMT, you will learn what its main classes are, so that you can create the objects you need, and make them interact to do the things you want to do. This is because wherever in Python, R or C++, using FMT means using its different objects.\nThe namespaces of FMT The different classes of objects in FMT are grouped into namespaces, which are simply different sections of its files.\nIn FMT, the different namespaces are :\n Parser : Classes used for reading or editing the files of the models in Woodstock format Models : Manipulating and solving the models Spatial : Making things spatially explicit Heuristics : Contains the heuristics used for spatially aggregating the cut blocks, and planning them through time Version : Contain informations about the current version of FMT, and the functions it contains (which depends on how it was compiled)   If you look at the importation of FMT in Python, you\u0026rsquo;ll see that we import the main namespaces that you will need into Python.   Important classes of the Parser namespace The Parser namespace contains two important class for reading models :\n FMTareaparser : Allows the reading and writing of the raster and vector files used in the spatial operations of FMT.  Some of its functions allows you to transform data between vector and raster format.   FMTmodelparser : Allows the reading of a model across all of the Woodstock model files with the readproject() function, or to save it with the write() function after modifying it.  The class also use other classes made to read Woodstock files.    The FMTmodel class The FMTmodel class is the basis of FMT.\nIt contains informations coming from the files of the models, in Woodstock format. This can be seen by looking at the properties of the FMTmodel :\n  However, these attributes are \u0026ldquo;protected\u0026rdquo; so that they are not edited in the wrong way. If you want to read them when using FMT, you will have to use the getter functions that will get them for you :\n  Additionally, you can edit them in the right way by using the setter functions. This allows you to edit different parts of the model.\n  In the end, the FMTModel is what we call a parent class for all of the different class of models that FMT uses, such as FMTlpmodel (linear programming model), and FMTsesmodel (spatialy explicit model) according to the following diagram :\nclassDiagram\rFMTobject \u0026lt;|-- FMTmodel\rFMTmodel \u0026lt;|-- FMTsamodel\rFMTmodel \u0026lt;|-- FMTsesmodel\rFMTmodel \u0026lt;|-- FMTsrmodel\rFMTsrmodel \u0026lt;|-- FMTlpmodel\rFMTsrmodel \u0026lt;|-- FMTnssmodel\r Observe that all of these classes ultimately inherit from the FMTobject class. This is the case for every object in FMT, as FMTobject contains useful functions and properties for debugging FMT.\nThe FMTnssmodel and FMTlpmodel are spatially referenced models. The FMTlpmodel is used for optimization, while FMTnssmodel is used for simulation.\nMeanwhile, the FMTsesmodel and FMTsamodel are spatially explicit models. In the same way, FMTsamodel is used for optimization, while FMTsesmodel is used for simulation.\nWe will take a closer look at the different types of models later. For now, we will only use the simplest model that correspond to a Woodstock model structure, the FMTlpmodel.\nLoading a simple FMTlpmodel Here is an example of how it looks like to read a linear programming model (in Woodstock format) with FMT.\nIn R, the code to use it would be :\nlibrary(FMT) # Loads FMT into R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # Checks if FMT has been compiled with OSI by creating a new FMTversion object, and using the function hasfeature().\r{\r# Creating the parser object to read the model files\rnewmodelparser \u0026lt;- new(FMTmodelparser)\r# Reading the project with the model parser by specifying that we want the scenario named \u0026quot;LP\u0026quot; (there can be different scenarios for one model)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\rmodel_scenario_lp \u0026lt;- modelslist[[1]]\r# We get the name of the model\rprint(model_scen_lp$getname())\r} else { # if the model hasn't been compiled with OSI, we display an error.\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\r In Python, the code would look like this:\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Creating the parser object to read the model files\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# Reading the project with the model parser by specifying that we want the scenario named \u0026quot;LP\u0026quot; (there can be different scenarios for one model)\rmodelslist = newmodelparser.readproject(path, scenarios)\rmodel_scen_lp = modelslist[0]\rprint(model_scen_lp.getname())\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r Wherever in the R prompt or the Python terminal, the result should give the following :\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\r[1] \u0026quot;LP\u0026quot;\r As you can see, FMT indicated that it has read the scenario \u0026ldquo;LP\u0026rdquo;, and returned its name.\nThe Core namespace The Core namespace contains elements used by FMT \u0026ldquo;under the hood\u0026rdquo; to make the FMTModel object function.\nFor example, it contains the objects :\n FMTaction : Class that defines the operability of multiple strata for a given disturbance. FMTtransition : Class that defines the transitions of multiple strata for a given disturbance. FMTyields : Class that defines the growth and yields values for every strata. FMToutputs : Class that defines the outputs in the model (inventory or action based), but not the outputs of the model (e.g., output files or others) FMTconstraints : Class that defines the global constraints and the objective of the model (e.g., variable to optimize).  These different objects can be called from a FMTmodel object with the different getter functions.\nFor example, to see the list of FMTaction objects associated with a particular FMTmodel, you can use the FMTModel.getactions() (or FMTModel$getactions() in R) function, and use a for loop to display every action other it. The actions displayed in such way will correspond to the actions present in the .act file of the Woodstock files for the model.\nHere is an example of displaying the actions and the transitions of a FMTmodel in R code :\nlibrary(FMT) # Loads FMT into R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # Checks if FMT has been compiled with OSI by creating a new FMTversion object, and using the function hasfeature().\r{\r# Creating the parser object to read the model files\rnewmodelparser \u0026lt;- new(FMTmodelparser)\r# Reading the project with the model parser by specifying that we want the scenario named \u0026quot;LP\u0026quot; (there can be different scenarios for one model)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\rmodel \u0026lt;- modelslist[[1]]\r# We get the name of the actions in the model\rprint(\u0026quot;***** Here is the name of the actions\u0026quot;)\rfor (action in model$getactions())\r{\rprint(action$getname())\r}\rprint(\u0026quot;***** Here is the name of the transitions\u0026quot;)\rfor (transition in model$gettransitions())\r{\r# We concatenate the entry for the transition to make it more readable in the prompt\rcat(transition$str())\r}\r} else { # if the model hasn't been compiled with OSI, we display an error.\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\r This R code will result in the following text in the R prompt :\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\r[1] \u0026quot;***** Here is the name of the actions\u0026quot;\r[1] \u0026quot;CLEARCUT\u0026quot;\r[1] \u0026quot;ACARIBOU\u0026quot;\r[1] \u0026quot;PLANTATION\u0026quot;\r[1] \u0026quot;AFIRE\u0026quot;\r[1] \u0026quot;ARECUP\u0026quot;\r[1] \u0026quot;_DEATH\u0026quot;\r[1] \u0026quot;***** Here is the name of the transitions\u0026quot;\r*CASE CLEARCUT\r*SOURCE ? ? ?\r*TARGET ? ? ? 100.000000\r*CASE ACARIBOU\r*SOURCE ? ? ?\r*TARGET ? ? ? 100.000000 _LOCK 1\r*CASE PLANTATION\r*SOURCE ? ? ?\r*TARGET ? STAND1 ? 100.000000\r*CASE AFIRE\r*SOURCE ? ? ?\r*TARGET ? FIRE ? 100.000000\r*CASE ARECUP\r*SOURCE ? FIRE ?\r*TARGET ? STAND1 ? 100.000000\r*CASE _DEATH\r*SOURCE ? ? ?\r*TARGET ? ? ? 100.000000\r The equivalent in Python code is :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Creating the parser object to read the model files\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# Reading the project with the model parser by specifying that we want the scenario named \u0026quot;LP\u0026quot; (there can be different scenarios for one model)\rmodelslist = newmodelparser.readproject(path, scenarios)\rmodel = modelslist[0]\r# We get the name of the actions in the model\rprint(\u0026quot;***** Here is the name of the actions\u0026quot;)\rfor action in model.getactions():\rprint(action)\rprint(\u0026quot;***** Here is the name of the transitions\u0026quot;)\rfor transition in model.gettransitions():\rprint(transition.getname())\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r Which will result in the following text in the Python terminal. Note that while the outputs between R and Python should usually be the same, there are sometimes small differences. Here, the Python version will display more information about the actions, and just the name of the transitions when compared to R; this is due to the particularities of the two languages.\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\r***** Here is the name of the actions\r*ACTION CLEARCUT Y\r*OPERABLE COUPETOTALE\r? ? ? TOTALVOLUME \u0026gt;= 100.000000\r*ACTION ACARIBOU N\r*OPERABLE ACARIBOU\rUC ? ? _AGE \u0026gt;= 8\r*ACTION PLANTATION Y _LOCKEXEMPT\r*OPERABLE PLANTATION\r? ? ? _AGE \u0026gt;= 1 AND _AGE \u0026lt;= 3\r*ACTION ARECUP Y\r*OPERABLE AFIRE\r? PROD ? _AGE \u0026gt;= 1\r*ACTION ARECUP Y\r*OPERABLE ARECUP\r? FEU ? _AGE = 0\r*ACTION _DEATH Y _LOCKEXEMPT\r*OPERABLE _DEATH\r? ? ? _AGE \u0026gt;= 80\r***** Here is the name of the transitions\rCLEARCUT\rACARIBOU\rPLANTATION\rAFIRE\rARECUP\r_DEATH\r Comparing elements in FMT A common operation to do in your scripts will be to compare elements : for example, to compare the name of a FMTaction object with the name of the action that you want to select, etc.\nIn such cases, remember that all strings read by FMT are automatically set to upper case strings. Therefore, if you want to compare elements name in FMT make sure the string is in uppercase.\nFor example, if you have an action named Clearcut or clearcut that you want to select, you will need to compare the name of the FMTactions of the models with the string CLEARCUT, all in upper case.\nConversion of errors to warnings All FMT classes inherit from the class FMTobject, and thus share the same FMTexceptionhandler and FMTlogger.\nIf the user want to ignore some error, he can use the function seterrorstowarnings of any FMT class and pass a vector of errors that the handler needs to consider warnings. This function is risky and can lead to errors. It is recommended that you investigate FMT error messages and correct the model accordingly.\n Now that you know everything about the structure of FMT and its basic elements, we will take a look at how to do spatially referenced optimization with it, which is one of the main functions of FMT.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"28124c8adfcb86aa5fb7c74a49d23b63","permalink":"/docs/basics/objects_parsing_interrogation/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/docs/basics/objects_parsing_interrogation/","section":"docs","summary":"What are objects ? FMT is made with a particular structure that is called Object-Oriented Programming (OOP). If you never heard of it, here is a very quick summary of it to better understand how to use FMT later.","tags":null,"title":"Objects, model parsing and interrogation","type":"book"},{"authors":null,"categories":null,"content":" Download and install Visual Studio Community   When installing Visual Studio Community, don\u0026rsquo;t forget to indicate during the installation that you want the Cmake build tool installed.    Visual Studio Community is the free version of the Visual Studio Software by Microsoft. We will use it later to compile FMT, as it comes with a compiler compatible with Windows.   Download and install Mosek   Mosek is a solver for linear programming problems, which is exactly the kind of problems that FMT deals with. However, FMT can work with different other solvers, both free or not free.   Create a FMT-Installation folder in your computer. Make sure that there is no spaces or accents in the path leading to the folder.   Spaces and accents in the path can cause errors with different programs and different steps of the compilations. It\u0026rsquo;s annoying, but that\u0026rsquo;s how it is !   Open a command prompt, and use the cd command to navigate to the FMT-Installation folder.   To open the command prompt on Windows 10, simply press the  key, type cmd, and then press Enter.\nThe cd command is used to change the folder inside which the command prompt is ready to act.\nType cd .. to go to the parent folder from the one you\u0026rsquo;re in, and cd folder to go into a folder.\n  ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"b66c69f45a1514d17932505c1f981ea0","permalink":"/docs/download_install/prerequisits/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/docs/download_install/prerequisits/","section":"docs","summary":"Download and install Visual Studio Community   When installing Visual Studio Community, don\u0026rsquo;t forget to indicate during the installation that you want the Cmake build tool installed.    Visual Studio Community is the free version of the Visual Studio Software by Microsoft.","tags":null,"title":"Prerequisits","type":"book"},{"authors":null,"categories":null,"content":" If you don\u0026rsquo;t have git installed on your computer, install it from here.   Git is a free and open-source software used to help organise the way that people create source code for programs and tool, and how they collaborate to do it.\nHere, git will help you download the code used to make the vcpkg software function, which will download all of the librairies that FMT needs for us.\n  Use git clone https://github.com/microsoft/vcpkg.git in the command prompt to download vcpkg.   If you have closed the command prompt, or if you don\u0026rsquo;t remember how to open it, see the previous page.   Use cd ./vcpkg in the command prompt to navigate into the vcpkg folder.   If you don\u0026rsquo;t remember how to use cd, see the previous page.   Copy/paste the following command in the command prompt to install the dependencies necessary to compile FMT :  vcpkg install boost:x64-windows boost-dll:x64-windows boost-icl:x64-windows boost-python:x64-windows gdal:x64-windows geos:x64-windows pthreads:x64-windows clp:x64-windows\r  This will take time, and will use some space on your computer (around 10Gb).\nJust leave the command prompt open so that vcpkg does its work.\n   Once vcpkg is done, go to the next page.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"bfc7fa201cc9979fa31631fd6f787541","permalink":"/docs/download_install/downloading_libraries/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/docs/download_install/downloading_libraries/","section":"docs","summary":"If you don\u0026rsquo;t have git installed on your computer, install it from here.   Git is a free and open-source software used to help organise the way that people create source code for programs and tool, and how they collaborate to do it.","tags":null,"title":"Downloading the libraries","type":"book"},{"authors":null,"categories":null,"content":"In the previous section, we\u0026rsquo;ve seen how to read a Woodstock model and load it into a FMTlpmodel object.\nFMTlpmodel will allow you to solve a spatially referenced linear programming model, giving you an optimized schedule of forest operations according to a goal and a set of constraints.\nHere, we will see how to do this optimization in practice.\nA quick reminder of the meaning of \u0026ldquo;spatially referenced\u0026rdquo; We can distinguish 3 ways that space can be taken into account in a model :\n In a non-spatial model or spatially implicit model, entities (e.g., forests, animals, agents, etc.) are not directly associated with a position in space, but the relation between them in the model can imply that only some of them interact with each other in a way to mimic a spatial disposition. In a spatially referenced model, entities are associated to regions in space, but not to a precise position in those regions; those regions can be non-continuous. Woodstock models are spatially referenced in nature, as they consider strata that correspond to forests with the same composition and age, which can be dispersed in many places in the landscape. In a spatially explicit model, entities are associated to precise coordinates in space, like in the pixels of a raster map.  The structure of the FMTlpmodel : FMTgraph and FMTdevelopment FMTlpmodel, FMTgraph and FMTdevelopment are three classes that are important to understand how a linear programming model is represented in FMT, and how to solve it.\nFMTlpmodel is a type III linear programming forest planning model, which is spatially referenced.\nIt can solve a type III forest planning model, and get an optimal harvest schedule using constraints and objectives defined by the user.\n The notion of type I, II and III of forest planning models correspond to a particular taxonomy relating to their mathematical structure, and to the way that they can be solved. Type III forest planning models are currently the most advanced type, and can be solved for large landscapes with a lot of forest area. You can learn more about them by reading this article.   The FMTlpmodel contains an object called the FMTgraph, which contains the graph of the model. The graph is an ensemble of nodes linked together with vertices. Each node correspond to a possible state for a particular strata (which are spatially referenced groups of forest forest stands with the same characteristics), with each vertex representing a particular way that it can evolve to another state in the same period of time and between periods.\nHere is a visual representation of a simple FMTgraph, in which a particular strata can evolve from different states (FMTdevelopment objects) with different transitions caused by different actions through the sme period of time. The evolution of the stands takes place between the periods and consists in increasing the age by 1 :\n  A FMTdevelopment is an important class of FMT. It represents a particular strata, which means a particular forest stand that has a given composition, age, and that exists at a particular time period.\nTherefore, the FMTdevelopment object is associated with a FMTmask object, which described the set of attributes (FMTtheme) that defines the FMTdevelopment. This is shown on the following visual :\n  FMTdevelopment is the parent class of two classes, FMTactualdevelopment and FMTfuturdevelopment. An FMTactualdevelopment always represents a strata at the beginning of the planning horizon and therefore contains information about the area. The FMTfuturdevelopment are the possible futures and therefore no area is allocated to them when the FMTgraph is built. This is the result of the optimization that informs us about the future distribution of the area through the FMTgraph.\n  Here are some functions of the FMTdevelopment class that can be important for manipulating the model for different purposes :\n FMTdevelopment.grow() can make the stand grow to see what it will become. Returns an FMTfuturdevelopment identical to the FMTdevelopment from which the function is called but with an increased age of 1 FMTdevelopment.operable() can test if a given action can be applied to this development, based on a yield section (e.g. a particular variable) FMTdevelopment.operate() can operate the stand, and return a vector of FMTdevelopmentpath  Now, we can take a look at how to build the \u0026ldquo;full graph\u0026rdquo; of the model, which is necessary to solve the FMTlpmodel.\nBuilding the full graph of the model The full graph of the model can be built via a repetition of the function FMTlpmodel.buildperiod(). This is essential to solve the model, as FMT will navigate this graph to find the optimal solution according to the objective and the constraints that we will set (see next section).\nThis function requires three parameters :\n A schedule of actions, on the form of a FMTschedule object (it can be empty to obtain the full graph for the model, containing every possibilities) An option to force a partial build (which we will not see right now) Another parameter for class operability (that we will not see either right now, and just set to 1)  Here is the code to build the full graph in R. Pay attention to the to the for loop that builds the different periods.\nlibrary(FMT) # Loads FMT into R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # Checks if FMT has been compiled with OSI by creating a new FMTversion object, and using the function hasfeature().\r{\r# Creating the parser object to read the model files\rnewparser \u0026lt;- new(FMTmodelparser)\r# Reading the project with the model parser by specifying that we want the scenario named \u0026quot;LP\u0026quot; (there can be different scenarios for one model)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\r# We cast the model in the \u0026quot;lpmodel\u0026quot; format for linear programming model by specifying the solver that we want to use\rsolverinterface \u0026lt;- list(CLP=1,MOSEK=2,CPLEX=3,GUROBI=4)\rlpmodel \u0026lt;- new(FMTlpmodel,modelslist[[1]],solverinterface$MOSEK)\r# We create an empty schedule to create the full graph\remptyschedule \u0026lt;- new(FMTschedule)\r# We loop around the different periods to build the full graph\rfor (period in 1:10)\r{\r# We also want the prompt to display what is happening\rprint(lpmodel$buildperiod(emptyschedule,FALSE,1)$str())\r}\r} else { # if the model hasn't been compiled with OSI, we display an error.\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\r The equivalent in Python code is the following (notice that in Python, we don\u0026rsquo;t have to make an empty schedule to build the full graph) :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Creating the parser object to read the model files\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# Reading the project with the model parser by specifying that we want the scenario named \u0026quot;LP\u0026quot; (there can be different scenarios for one model)\rmodelslist = newmodelparser.readproject(path, scenarios)\r# We cast the model in the \u0026quot;lpmodel\u0026quot; format for linear programming model by specifying the solver that we want to use\rlpmodel = Models.FMTlpmodel(modelslist[0], Models.FMTsolverinterface.CLP)\r# We loop around the different periods to build the full graph\rfor period in range(1, 11):\rprint(lpmodel.buildperiod())\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r The output of both codes should be the following :\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\rColumns: 58 Rows: 29 Vertices: 60 Edges: 58 Transfer Rows: 29 Output Rows: 0 Output Columns: 0\rColumns: 169 Rows: 87 Vertices: 141 Edges: 169 Transfer Rows: 87 Output Rows: 0 Output Columns: 0\rColumns: 336 Rows: 164 Vertices: 237 Edges: 336 Transfer Rows: 164 Output Rows: 0 Output Columns: 0\rColumns: 553 Rows: 259 Vertices: 350 Edges: 553 Transfer Rows: 259 Output Rows: 0 Output Columns: 0\rColumns: 805 Rows: 372 Vertices: 481 Edges: 805 Transfer Rows: 372 Output Rows: 0 Output Columns: 0\rColumns: 1088 Rows: 503 Vertices: 630 Edges: 1088 Transfer Rows: 503 Output Rows: 0 Output Columns: 0\rColumns: 1407 Rows: 652 Vertices: 797 Edges: 1407 Transfer Rows: 652 Output Rows: 0 Output Columns: 0\rColumns: 1762 Rows: 819 Vertices: 982 Edges: 1762 Transfer Rows: 819 Output Rows: 0 Output Columns: 0\rColumns: 2177 Rows: 1015 Vertices: 1196 Edges: 2177 Transfer Rows: 1015 Output Rows: 0 Output Columns: 0\rColumns: 2660 Rows: 1244 Vertices: 1443 Edges: 2660 Transfer Rows: 1244 Output Rows: 0 Output Columns: 0\r As we can see, the prompt shows us the evolutions of the characteristics of the FMTgraph as it gets built (increasing number of columns, vertices, etc.).\nConstraints and objective Linear programming models come with constraints and objectives, for which we want an optimized solution.\nHence, to solve a FMTlpmodel, we need to set these constraints and objectives into the model before attempting to solve it.\nThese constraints and objectives can be set manually via the FMTlpmodel.setobjective() and the FMTlpmodel.setconstraints() functions.\nMost of the time, you might end up doing the following :\n Getting the constraints that are already in the Woodstock files formulation of the model using the FMTmodel.getconstraint() function. Taking out the first constraint out of the list of constraints that FMTmodel.getconstraint() returns, because the first constraint of this list is actually the objective function of the model. Then, inserting this objective function and the constraints into the FMTlpmodel in order to solve it, by using the FMTlpmodel.setobjective() and FMTlpmodel.setconstraint() functions.  This will result in the following code, in R :\nlibrary(FMT) # Loads FMT into R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # Checks if FMT has been compiled with OSI by creating a new FMTversion object, and using the function hasfeature().\r{\r# Creating the parser object to read the model files\rnewparser \u0026lt;- new(FMTmodelparser)\r# Reading the project with the model parser by specifying that we want the scenario named \u0026quot;LP\u0026quot; (there can be different scenarios for one model)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\r# We cast the model in the \u0026quot;lpmodel\u0026quot; format for linear programming model by specifying the solver that we want to use\rsolverinterface \u0026lt;- list(CLP=1,MOSEK=2,CPLEX=3,GUROBI=4)\rlpmodel \u0026lt;- new(FMTlpmodel,modelslist[[1]],solverinterface$MOSEK)\r# We create an empty schedule to create the full graph\remptyschedule \u0026lt;- new(FMTschedule)\r# We loop around the different periods to build the full graph\rfor (period in 1:10)\r{\r# We also want the prompt to display what is happening\rprint(lpmodel$buildperiod(emptyschedule,FALSE,1)$str())\r}\r# We get the constraints and objectives\rallmodelconstraints \u0026lt;- lpmodel$getconstraints()\r# We define the first constraint of the list as the objective function of the model\rmodelobjective \u0026lt;- allmodelconstraints[[1]]\r# We define all of the other constraints of the list as constraints\rmodelconstraints \u0026lt;- allmodelconstraints[2:length(allmodelconstraints)]\r# We apply all of the constraints to the model\rfor (constraint in modelconstraints)\r{\rprint(lpmodel$setconstraint(constraint)$str())\r}\r# We apply the objective function to the model\rprint(lpmodel$setobjective(modelobjective)$str())\r} else { # if the model hasn't been compiled with OSI, we display an error.\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\r The equivalent in Python code is the following (notice that here, we will just \u0026ldquo;take out\u0026rdquo; the objective function out of the list of constraints returned by FMTlpmodel.getconstraints() with the function list.pop(), which we allow us to directly loop around the remaining list for the constraints) :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Creating the parser object to read the model files\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# Reading the project with the model parser by specifying that we want the scenario named \u0026quot;LP\u0026quot; (there can be different scenarios for one model)\rmodelslist = newmodelparser.readproject(path, scenarios)\r# We cast the model in the \u0026quot;lpmodel\u0026quot; format for linear programming model by specifying the solver that we want to use\rlpmodel = Models.FMTlpmodel(modelslist[0], Models.FMTsolverinterface.CLP)\r# We loop around the different periods to build the full graph\rfor period in range(1, 11):\rprint(lpmodel.buildperiod())\r# We get the constraints and objectives\rconstraints = lpmodel.getconstraints()\r# We define the first constraint of the list as the objective function of the model\robjective = constraints.pop(0)\r# We apply all of the constraints to the model\rfor constraint in constraints:\rlpmodel.setconstraint(constraint)\r# We apply the objective function to the model\rlpmodel.setobjective(objective)\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r Solving the FMTlpmodel Once that the full graph is built, and that the constraints and objectives are set, the FMTlpmodel can be solved by using the FMTlpmodel.initialsolve() function. The function returns true or false depending on whether the model was successfully resolved. If the resolution went well, the model retains the solution and the solution can be queried in different ways (an example is shown below).\nBuilding the graph with an existing solution (partial build) Sometime, we might want to get some outputs of a solution/schedule that we already have (see next section) without solving the model all over again, as it was already solved previously.\nIn that case, it is possible to read a solution that was previously found, and to build the FMTgraph of the model by generating only the edges and vertices used by the solution.\nTo that end, three things must be done :\n Reading the schedule file of the scenario, and passing it to the FMTlpmodel.buildperiod() function. Setting the solution for each period with the FMTlpmodel.setsolution() function  If the model contains multiple _LOCKEXEMPT actions, then using FMTlpmodel.setsolution() can throw errors as locks specifications are not part of the solution. In such a case, you should use the FMTlpmodel.setsolutionbylp() function.    This will result in the following code, in R :\nlibrary(FMT) # Loads FMT into R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # Checks if FMT has been compiled with OSI by creating a new FMTversion object, and using the function hasfeature().\r{\r# Creating the parser object to read the model files\rnewparser \u0026lt;- new(FMTmodelparser)\r# Indicating where the model and the existing solution are\rprimarylocation \u0026lt;- \u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;\r# Reading the project with the model parser by specifying that we want the scenario named \u0026quot;LP\u0026quot; (there can be different scenarios for one model)\rmodelslist \u0026lt;- newmodelparser$readproject(primarylocation, c(\u0026quot;LP\u0026quot;), TRUE, TRUE, TRUE)\r# We cast the model in the \u0026quot;lpmodel\u0026quot; format for linear programming model by specifying the solver that we want to use\rsolverinterface \u0026lt;- list(CLP=1,MOSEK=2,CPLEX=3,GUROBI=4)\rlpmodel \u0026lt;- new(FMTlpmodel,modelslist[[1]],solverinterface$MOSEK)\r# We read the existing schedule, which is the first of the list returned by the function\rschedules \u0026lt;- newparser$readschedules(primarylocation,modelslist)[[1]]\r# We create a \u0026quot;tolerance\u0026quot; variable that is needed for the setsolution function\rtolerance \u0026lt;- 0.0001\r# We loop around the different periods to build the partial graph with the existing solution\rfor (period in 1:length(schedules))\r{\rprint(lpmodel$buildperiod(schedules[[period]],TRUE,1)$str())\r}\r# We set the solution of the model at each period\rfor (period in 1:length(schedules))\r{\r# We make an if statement to have an indication if FMT succeeded in applying the solution at this period\rif (lpmodel$setsolution(period, schedules[[period]], tolerance))\r{\rprint(paste(\u0026quot;Solution set at period \u0026quot;, period))\r}\r}\r} else { # if the model hasn't been compiled with OSI, we display an error.\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\r Notice that here, we have a second parameter TRUE to lpmodel$buildperiod() to indicate that we needed to force a partial build, as indicated in the documentation of the function :\n  Also notice that we created a variable named tolerance, which is needed by the lpmodel$setsolution() function, as indicated by the documentation once again :\n  The equivalent in Python code is the following :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# Creating the parser object to read the model files\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;LP\u0026quot;]\r# Reading the project with the model parser by specifying that we want the scenario named \u0026quot;LP\u0026quot; (there can be different scenarios for one model)\rmodelslist = newmodelparser.readproject(path, scenarios)\r# We cast the model in the \u0026quot;lpmodel\u0026quot; format for linear programming model by specifying the solver that we want to use\rlpmodel = Models.FMTlpmodel(modelslist[0], Models.FMTsolverinterface.CLP)\r# We create a \u0026quot;tolerance\u0026quot; variable that is needed for the setsolution function\rtolerance = 0.0001\r# We read the existing schedule, which is the first of the list returned by the function\rschedules = newmodelparser.readschedules(path, modellist)[0]\r# We loop around the different periods to build the partial graph with the existing solution\rfor periodschedule in range(len(schedules)):\rprint(lpmodel.buildperiod(schedules[periodschedule], False, 1))\r# We set the solution of the model at each period (we use +1 as Python use a 0 based numbering)\rfor periodschedule in range(len(schedules)):\rlpmodel.setsolution(periodschedule+1, schedules[periodschedule], tolerance)\rprint(\u0026quot;Solution set at period\u0026quot;, periodschedule+1) else:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r The output of both codes should be the following :\nReading Models/TWD_land/TWD_land.pri\rFMT 0.9.1, build: Sep 30 2021 12:07:49\rTue Oct 05 10:59:57 2021\rReading Scenario Lp\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rFMTexc(40)Undefined _death transition: _DEATH FMTsection(5)Transition\rDone reading Tue Oct 05 10:59:57 2021\rColumns: 20 Rows: 10 Vertices: 28 Edges: 20 Transfer Rows: 10 Output Rows: 0 Output Columns: 0\rColumns: 40 Rows: 25 Vertices: 48 Edges: 40 Transfer Rows: 25 Output Rows: 0 Output Columns: 0\rColumns: 63 Rows: 44 Vertices: 71 Edges: 63 Transfer Rows: 44 Output Rows: 0 Output Columns: 0\rColumns: 90 Rows: 67 Vertices: 98 Edges: 90 Transfer Rows: 67 Output Rows: 0 Output Columns: 0\rColumns: 123 Rows: 95 Vertices: 131 Edges: 123 Transfer Rows: 95 Output Rows: 0 Output Columns: 0\rColumns: 157 Rows: 126 Vertices: 165 Edges: 157 Transfer Rows: 126 Output Rows: 0 Output Columns: 0\rColumns: 198 Rows: 162 Vertices: 206 Edges: 198 Transfer Rows: 162 Output Rows: 0 Output Columns: 0\rColumns: 244 Rows: 203 Vertices: 252 Edges: 244 Transfer Rows: 203 Output Rows: 0 Output Columns: 0\rColumns: 294 Rows: 248 Vertices: 301 Edges: 294 Transfer Rows: 248 Output Rows: 0 Output Columns: 0\rColumns: 351 Rows: 298 Vertices: 356 Edges: 351 Transfer Rows: 298 Output Rows: 0 Output Columns: 0\rColumns: 405 Rows: 350 Vertices: 410 Edges: 405 Transfer Rows: 350 Output Rows: 0 Output Columns: 0\rColumns: 467 Rows: 407 Vertices: 472 Edges: 467 Transfer Rows: 407 Output Rows: 0 Output Columns: 0\rColumns: 532 Rows: 468 Vertices: 537 Edges: 532 Transfer Rows: 468 Output Rows: 0 Output Columns: 0\rColumns: 599 Rows: 532 Vertices: 604 Edges: 599 Transfer Rows: 532 Output Rows: 0 Output Columns: 0\rColumns: 673 Rows: 601 Vertices: 678 Edges: 673 Transfer Rows: 601 Output Rows: 0 Output Columns: 0\rColumns: 745 Rows: 671 Vertices: 749 Edges: 745 Transfer Rows: 671 Output Rows: 0 Output Columns: 0\rColumns: 828 Rows: 747 Vertices: 831 Edges: 828 Transfer Rows: 747 Output Rows: 0 Output Columns: 0\rColumns: 912 Rows: 827 Vertices: 915 Edges: 912 Transfer Rows: 827 Output Rows: 0 Output Columns: 0\rColumns: 998 Rows: 910 Vertices: 1001 Edges: 998 Transfer Rows: 910 Output Rows: 0 Output Columns: 0\rColumns: 1091 Rows: 998 Vertices: 1094 Edges: 1091 Transfer Rows: 998 Output Rows: 0 Output Columns: 0\rSolution set at period 1\rSolution set at period 2\rSolution set at period 3\rSolution set at period 4\rSolution set at period 5\rSolution set at period 6\rSolution set at period 7\rSolution set at period 8\rSolution set at period 9\rSolution set at period 10\rSolution set at period 11\rSolution set at period 12\rSolution set at period 13\rSolution set at period 14\rSolution set at period 15\rSolution set at period 16\rSolution set at period 17\rSolution set at period 18\rSolution set at period 19\rSolution set at period 20\r Getting output values from the model There are multiple ways to read different outputs from the model.\nIn R, there is a particular function (only available in R) called getoutsdataframe(); but for R, Python and C++, it is possible to use the FMTmodel.getoutputs() to get a list of the available outputs for a given model.\nIt is possible to select a different FMToutputlevel in order to obtain an output at different scales in the model.\nFor an example of this, see exercise 1.\nExporting the schedule of a solved model Exporting the schedule of a solved model is done via the FMTscheduleparser object that we used when building the partial graph (see previous sections).\nThe solution of a model can be put into a list by using the FMTlpmodel.getsolution() function for each of the period of interest.\nThen, the list of solution for each period must be transformed into a vector, which can then be written in a .txt file using the FMTscheduleparser.write() function.\nFor an example, see exercise 1.\nPre-solving a model Some models can be hard to solve, because of their high number of actions, strata, and so on.\nIn such case, the FMTmodel.basepresolve() function can be used to pre-solve the model.\nWhat this function does is to return a model with less themes, actions, transitions, outputs and constraints compare to the original model, but with the same amount of information. This makes it easier to solve, while giving the same answer in the end.\nIn some situations, FMT will pre-solve the model automatically.\n Now that you know everything there is to know about spatially referenced optimization in FMT, we recommand that you try the exercise 1 to help you learn using FMT in practice. In this exercise, you will learn to use some of the most regularly used functions by yourself.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"1944b4f83faa7919c3330c50fbf3bbde","permalink":"/docs/basics/spatially_referenced_optimization/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/docs/basics/spatially_referenced_optimization/","section":"docs","summary":"In the previous section, we\u0026rsquo;ve seen how to read a Woodstock model and load it into a FMTlpmodel object.\nFMTlpmodel will allow you to solve a spatially referenced linear programming model, giving you an optimized schedule of forest operations according to a goal and a set of constraints.","tags":null,"title":"Spatially referenced optimization","type":"book"},{"authors":null,"categories":null,"content":"Now that everything is ready, it is time to get into the compiling step proper.\n  Use cd .. to go back to the FMT-Installation folder.\n  Clone the repository of FMT by using git clone https://github.com/gcyr/FMT.git\n  Use cd ./FMT to navigate into the FMT folder downloaded from the repository of FMT.\n  Copy/paste the following commands in the Windows notepad, and then replace the -DMOSEK_DIR parameter with the location of Mosek on your computer:\n  cmake CMakeLists.txt -B build/release -G \u0026quot;Visual Studio 16 2019\u0026quot; -DVCPKG_TARGET_TRIPLET=x64-windows -DCMAKE_TOOLCHAIN_FILE=\u0026quot;../vcpkg/scripts/buildsystems/vcpkg.cmake\u0026quot; -DBOOST_DIR=\u0026quot;../vcpkg/installed/x64-windows/\u0026quot; -DCMAKE_BUILD_TYPE=Release -DGDAL_DIR=\u0026quot;../vcpkg/installed/x64-windows/\u0026quot; -DGEOS_DIR=\u0026quot;../vcpkg/installed/x64-windows/\u0026quot; -DOSI_DIR=\u0026quot;../vcpkg/installed/x64-windows/\u0026quot; -DPYTHON_DIR=\u0026quot;../vcpkg/packages/python3_x64-windows/\u0026quot; -DMOSEK_DIR=\u0026quot;C:/PROGRA~1/Mosek/\u0026quot;\rcmake --build build/release --config Release\rcmake --install build/release --config Release\r  By default, Mosek was installed in your C:/Program Files folder on windows. This can be expressed by the path C:/PROGRA~1 to avoid the space between Program and Files, which can create errors.\nThus, if you installed Mosek in C:\\Program Files\\Mosek, you can keep C:/PROGRA~1/Mosek/ in the commands.\n  Copy/paste all of the commands that are ready in the notepad into the command prompt to start the compilation. Press enter to activate them.   This will take time, and you might see warning in the command prompt during the process. Don\u0026rsquo;t worry about them.    If the compilation ends up with error messages that are red, you can come and post an issue on the issue page of the repository for FMT.    If everything worked, congratulations ! Now, it leaves us with importing FMT in Python, and seeing that everything works.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"28b33694d2653cd0b0dcc16d3adf2fb2","permalink":"/docs/download_install/compiling/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/docs/download_install/compiling/","section":"docs","summary":"Now that everything is ready, it is time to get into the compiling step proper.\n  Use cd .. to go back to the FMT-Installation folder.\n  Clone the repository of FMT by using git clone https://github.","tags":null,"title":"Compiling","type":"book"},{"authors":null,"categories":null,"content":"In this exercise, you will try to use FMT to read a scenario, solve it, read one of its outputs, and export the solution.\nIn order to do the exercise, you will need to have FMT installed on your computer, and to have downloaded the example files from the GitHub repository of FMT.\n ðŸ’¾ Downloading and installing FMT    ðŸ’¾ Downloading the example files of FMT   Goals of the exercise Use FMT to :\n Read the Woodstock model TWD_land in the example files by selecting its scenario named LP.  Remember to select the CLP solver while parsing the model.   Solve the model by  Constructing its full graph for 10 periods Setting the objective and constraints of the model Using the FMTmodel.initialsolve() function to solve it.   Read the values of the output OSUPREC of the model by  Getting a list of the outputs of the model with the function FMTmodel.getouputs() Doing a for loop to select the right output with the FMToutput.getname() function Printing the output values using the function FMTmodel.getvariabilities(FMToutput)   Write the optimized schedule of the model in a .txt file by  Creating a new FMTscheduleparser object Getting the solution of the model at each period with a list using LPModel.getsolution(period) Transforming the list into a vector Writing the vector into a .txt file with FMTscheduleparser.write()    You can use the information from the previous pages of documentation to help you.\nWhen you are done, or if you are stuck, you can display the correction of this exercise for Python by clicking on the \u0026ldquo;Reveal correction\u0026rdquo; below.\nCorrection Reveal correction #%% LOADING FMT\r# Here, we load FMT directly, as if it were installed\r# via pip.\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\r#%% LOADING THE WOODSTOCK MODEL\r# Creation of a parser to read the model\rmodelParser = Parser.FMTmodelparser()\r# Defining the path leading to the Woodstock model .pri file.\r# WARNING : try to have a path without spaces inside it.\rpathToWoodstockModel = \u0026quot;\u0026lt;Path to example folder\u0026gt;/Examples/Models/TWD_land/TWD_land.pri\u0026quot;\r# Defining the scenario to be read, which contains a set of constraints and objectives.\rscenariosToSelect = [\u0026quot;LP\u0026quot;]\r# Reading the model using the parser and the scenario name. We can read multiple at once,\r# but here, we'll only use one.\rlistOfModelsParsed = modelParser.readproject(pathToWoodstockModel, scenariosToSelect)\r# Loading the model from the list of models given by the parser. We only take the first\r# one, which is the only one that we want. We also indicate the solver interface that we\r# will use to solve the linear programming model; here, we will use CLP, the free and\r# open-source solver.\rLPModel = Models.FMTlpmodel(listOfModelsParsed[0], Models.FMTsolverinterface.CLP)\r#%% SOLVING THE MODEL\r# We build the full graph of the model for 10 periods.\rfor period in range(1, 11):\rprint(LPModel.buildperiod())\r# The objective is simply the first item of the\r# constraints list, that we take away from the list with pop().\rconstraintsOfModel = LPModel.getconstraints()\robjectiveOfModel = constraintsOfModel.pop(0)\r# We set the contraints and objectives of the model.\rfor constraint in constraintsOfModel:\rprint(LPModel.setconstraint(constraint))\rprint(LPModel.setobjective(objectiveOfModel))\r# We solve the model.\rLPModel.initialsolve()\r#%% READING THE OSUPREC OUTPUT\r# We can read OSUPREC before the model is solved, but the values won't be interesting\r# to us.\routputWanted = \u0026quot;OSUPREC\u0026quot;\r# We get the outputs of the model\routputsOfModel = LPModel.getoutputs()\r# We loop around the list of output to select the one with the\r# right name\rfor output in outputsOfModel:\rprint(output.getname())\rif output.getname() == outputWanted:\r# We print the measures of \u0026quot;OSUPREC\u0026quot; in the python prompt\rprint(LPModel.getvariabilities([output]))\r# We save the values of OSUPREC to format them better\rosuprecValues = LPModel.getvariabilities([output])\r# Here is a small code to display the values better,\r# adapting to the fact that the getvariabilities() function\r# returns the minimum, mean and maximum value of the output.\rprint(\u0026quot;\\n\\n ###############################\u0026quot;)\rprint(\u0026quot;Values of \u0026quot; + outputWanted + \u0026quot; :\\n\u0026quot;)\rprint(\u0026quot;PERIOD\\t\\tMINIMUM\\t\\tMEAN\\t\\tMAXIMUM\u0026quot;)\rfor period in range(1, 11):\rprint(str(period) + \u0026quot;\\t\\t\\t\u0026quot; + str(round(osuprecValues[\u0026quot;L\u0026quot;+outputWanted][period-1], 2))\r+ \u0026quot;\\t\\t\u0026quot; + str(round(osuprecValues[\u0026quot;M\u0026quot;+outputWanted][period-1], 2))\r+ \u0026quot;\\t\\t\u0026quot; + str(round(osuprecValues[\u0026quot;U\u0026quot;+outputWanted][period-1], 2)))\r#%% WRITING THE SCHEDULE\r# We create a new scheduleparser object\rscheduleParser = Parser.FMTscheduleparser()\r# We get the solution of the model\rmodelSolution = list()\rfor period in range(1, 11):\rmodelSolution.append(LPModel.getsolution(period))\r# We write everything into a .txt file after putting everything as a vector.\rmodelSolutionAsVector = [[i] for i in modelSolution]\rscheduleParser.write(modelSolution, r\u0026quot;D:/TempCode/FMT/FMT/Examples/programme.txt\u0026quot;)\r  ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"c5750174bd25f564fd2b5739892c8360","permalink":"/docs/basics/exercice_1/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/docs/basics/exercice_1/","section":"docs","summary":"In this exercise, you will try to use FMT to read a scenario, solve it, read one of its outputs, and export the solution.\nIn order to do the exercise, you will need to have FMT installed on your computer, and to have downloaded the example files from the GitHub repository of FMT.","tags":null,"title":"Exercise 1","type":"book"},{"authors":null,"categories":null,"content":"To import FMT that you just compiled into Python, you need to have Python and pip installed on your computer.\n If you don\u0026rsquo;t have Python installed, we recommand to you install Miniconda, the \u0026ldquo;light\u0026rdquo; version of the popular Anaconda Python distribution. Miniconda contains Python, pip, and many other packages that are usefull when using FMT.   There are two ways to import FMT into Python :\n By using sys.path.append  sys.path.append allows you to tell Python where to find the FMT library.\nIf you use it, the beginning of your Python scripts will look like this :\nimport sys\rsys.path.append(r\u0026quot;\u0026lt;Path to FMT folder\u0026gt;/\u0026quot;)\rsys.path.append(r\u0026quot;\u0026lt;Path to FMT folder\u0026gt;/Release/\u0026quot;)\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Core\rfrom FMT import Version\r in which Path to FMT folder will be replaced with the location of the folder where the FMT files that you\u0026rsquo;ve downloaded from GitHub are.\nIt can get redondant however, which make the second option - installing with pip - more interesting.\nBy using pip and the Python wheel that you\u0026rsquo;re compiled  Python wheels are files that contain everything necessary for a Python module to be installed in your Python environment with the pip command. When installed in such a way, the module can be activated quicker in your python scripts.\nTo install the Python wheel that you\u0026rsquo;ve compiled, use the following command in a command prompt (if you have installed Python and pip independantly of Anaconda or Miniconda), or in an Anaconda prompt :\npip install \u0026quot;\u0026lt;path to FMT folder\u0026gt;\\build\\release\\bin\\Release/FMT-0.9.1-py3-none-any.whl\u0026quot;\r Once this is done, you\u0026rsquo;ll be able to import FMT in your scripts more quickly :\nfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Core\rfrom FMT import Version\r  And that\u0026rsquo;s it, you\u0026rsquo;re done ðŸŽŠðŸŽ‰! Now, you can start using FMT !\n If you had any issues during the process of downloading and installing FMT, please post an issue on the issue page of the repository for FMT.   ","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"3b4e5515a8180b52d201ea181148e8d7","permalink":"/docs/download_install/importing_in_python/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/docs/download_install/importing_in_python/","section":"docs","summary":"To import FMT that you just compiled into Python, you need to have Python and pip installed on your computer.\n If you don\u0026rsquo;t have Python installed, we recommand to you install Miniconda, the \u0026ldquo;light\u0026rdquo; version of the popular Anaconda Python distribution.","tags":null,"title":"Importing FMT in Python","type":"book"},{"authors":null,"categories":null,"content":"A quick reminder of the meaning of \u0026ldquo;spatially explicit\u0026rdquo; We can distinguish 3 ways that space can be taken into account in a model :\n In a non-spatial model or spatially implicit model, entities (e.g., forests, animals, agents, etc.) are not directly associated with a position in space, but the relation between them in the model can imply that only some of them interact with each other in a way to mimic a spatial disposition. In a spatially referenced model, entities are associated to regions in space, but not to a precise position in those regions; those regions can be non-continuous. Woodstock models are spatially referenced in nature, as they consider strata that correspond to forests with the same composition and age, which can be dispersed in many places in the landscape. In a spatially explicit model, entities are associated to precise coordinates in space, like in the pixels of a raster map.  The FMTsesmodel FMTsesmodel is a particular model that gives the user the opportunity to spatialize solutions coming from any FMTsrmodel class, which are the spatially referenced models (see objects, model parsing and interrogation and spatially referenced optimization).\nNote that we are not talking about optimizing a spatially explicit model; this is quite a complex task that is still on the roadmap of FMT (and which is the goal of the FMTsamodel class).\nclassDiagram\rFMTmodel \u0026lt;|-- FMTsamodel\rFMTmodel \u0026lt;|-- FMTsesmodel\rFMTmodel \u0026lt;|-- FMTsrmodel\rFMTsrmodel \u0026lt;|-- FMTlpmodel\rFMTsrmodel \u0026lt;|-- FMTnssmodel\r Instead, the FMTsesmodel will try to spatialize the schedule of a FMTsrmodel by placing cut blocks on a map, by doing multiple iterations of simulating the placement of these blocks, and by selecting the best solution that is found.\nTo use a metaphor, this would be like trying to find a winning position at chess if you don\u0026rsquo;t find yourself capable of finding it by thinking carefully about the placement of your chess pieces : you could try to place your pieces randomly many, many times, and asking each time if you have won, or if you are closer to victory, and if the position of the chess pieces respect the rules of the game.\nHere, FMTsesmodel will try to place cut blocks according to the solution of a FMTsrmodel (which is a schedule of forest operations applied to spatially referenced strata). Its goal will be to find the best positioning possible, by accommodating to the constraints that are set in their placement as best as possible, and by maximizing the objective value (e.g. maximizing the harvested wood).\nHowever, this method have a low chance of finding the optimal placement, if one exists; instead, the more iterations it does in trying to place them, there higher the chance to find a solution that is as close as possible as an optimal placement of the cut blocks in space. This is why this process represents what we call a heuristic.\nThe spatial framework inside FMT FMT uses FMTlayers to represent any spatially explicit solution.\nA FMTlayer can be compared to a regular raster file in which pixels can contain pretty much any type or class of forest stand.\nIn the FMTsesmodel, we use the FMTspatialschedule class to represent a spatially explicit solution, which itself is a FMTlayer of FMTlinegraph.\nEach FMTlinegraph is a linear version of the FMTgraph described in spatially referenced optimization. What that means is that they show the evolution of the FMTdevelopment inside the pixel from the beginning to end of the periods that we want to take into account.\nThe FMTspatialschedule class The FMTspatialschedule class contains a spatially explicit solution under the form of a FMTlayer.\nIt contains an important function, FMTspatialschedule.getsolutionstatus(), which prints important information about how much the solution contained in the FMTspatialschedule achieves the objective function of the model.\nThis function also gives a value of the primal infeasibility, which gives an idea of how much the current solution does not respect all of the constraints of the model at once.\nNote that unlike the FMTschedule object which only concern one periods of time (which is why the code shown in the section about spatially referenced optimization contained a for loop around the number of period of interest when dealing with the FMTschedule class), FMTspatialschedule contains a solution for multiple periods of time at once.\nThe FMTlinegraph As said earlier, the spatial structure of a FMTsesmodel is like a raster map made of pixels, with each pixels being a FMTlinegraph.\nIn a FMTlinegraph, each node stands for the state of the strata inside the pixel and each edge stands for an action (e.g. cleartcut) or natural growth, as shown of this image :\n  However, on the contrary of the FMTgraph object described in the section about spatially referenced optimization, the FMTlinegraph does not contain a complete enumeration of all possible actions and states possible for the strata in the pixel : instead, it only contains one solution, or one evolution possible for the strata.\nMaking transitions with single outputs A limitation of the FMTlinegraph class is that one cannot use multiple output transitions, meaning transitions that results in two different strata or other outputs, as illustrated below :\n  Therefore, you will need to modify the transitions of an FMTmodel to be able to use them in a FMTsesmodel.\nTo that end, you can use the FMTtransition.single() function, which automatically transforms multiple outputs transitions into single output transitions.\nOnce that the transitions have been transformed as single transitions, you can use the FMTsesmodel.settransitions() function to set the new generated transitions into the FMTsesmodel.\nSpatial events The FMTspatialschedule also keeps tracks of the areas affected by particular actions under the form of space time events with the class FMTevent, as is shown here :\n  FMTevent can represent any kind of spatially explicit disturbance (cut, fire, etc.). It is associated with the time period of the event, and the coordinates of the spatial event.\n  The initial forest map As a spatially explicit model, the FMTsesmodel requires spatially explicit informations about the forests in the landscape at the beginning of the planning horizon.\nTo get this information from a Woodstock model (that might have served to create a FMTlpmodel that you optimized; see spatially referenced optimization), you will need to retrieve this information from the vector file that serves as the Woodstock model\u0026rsquo;s map. This vector file contains information about the theme, age and lock attributes for each strata which will need to be transferred into multiple spatially explicit rasters.\nAll of this information will be contained in the FMTforest object, which is the equivalent of the model\u0026rsquo;s map, but that is based on a FMTlayer. Each pixel of a FMTforest object contains a FMTactualdevelopment object.\nThe FMTareaparser class can be used to generate the FMTforest needed for the FMTsesmodel, as it contains functions to read vectorial or raster maps from a Woodstock model.\n FMTareaparser.vectormaptoFMTforest() allows you to read an existing vector (shapefile) map FMTareaparser.readrasters() allows you to read existing rasters maps  Both functions require several parameters to properly identify the themes that are needed, and specify several spatial characteristics of the FMTforest class that you will create.\nOnce that the FMTforest is created, it needs to be given to the FMTsesmodel by using the FMTsesmodel.setinitialmapping() function.\nUsing new keywords in Woodstock files for spatial constraints In a usual Woodstock model, spatial constraints are not taken into account. However, you will certainly need to use some for a spatial simulation with the FMTsesmodel to place the cut blocks of the optimized schedule.\nTo that end, FMT can read two new keywords in the optimize section of a Woodstock model that do not exist in the original Woodstock syntax.\nThese keywords are _SIZE and _ADJACENCY.\n_SIZE is to be used with the following syntax in the optimize section of a Woodstock model :\n_SIZE(ACTION, NEIGHBORSIZE) \u0026gt;= \u0026lt;SIZE IN PIXELS\u0026gt; \u0026lt;PERIODS\u0026gt;\nNote that :\n ACTION can also be an aggregate of several actions, so that multiple actions can be subject to the same constraint NEIGHBORSIZE describe how the spatial event spread from one pixel to another pixel, following this graph :   \u0026lt;PERIODS\u0026gt; correspond to the period of time for which to set the constraint  As such, the _SIZE constraint can give a minimal or maximal size for the event of specified actions, in number of contiguous pixels. It will result in the creation of spatial blocks of pixels where the action has been applied.\nMeanwhile, _ADJACENCY is used with the following syntax :\n_ADJACENCY(ACTION, GREENUP) \u0026gt;= \u0026lt;DISTANCE\u0026gt; \u0026lt;PERIODS\u0026gt;\nWith :\n ACTION can again be an aggregate of several actions, so that multiple actions can be subject to the same constraint. \u0026lt;PERIODS\u0026gt; again correspond to the period of time for which to set the constraint. DISTANCE corresponds to the minimal or maximal adjacency distance between two spatial blocks of one or several actions (whose size was defined by _SIZE). Hence, for a DISTANCE \u0026gt;= 3, we will have the following :   GREENUP correspond to the number of time periods for which we consider two events to be neighbours. For example, if GREENUP is equal to 3, two spatial blocks of actions that are under the maximal distance indicated by DISTANCE but which are separated temporally by 4 periods will not be considered spatially adjacent; however, if they were separated by 3, 2 or 1 period, or are in the same period, they will be considered spatially adjacent.  Making the simulation with FMTsesmodel.Greedyreferencebuild() Once that you have a spatially-referenced solution/schedule (see spatially referenced optimization) and that you have set the initial landscape for the FMTsesmodel (see previous sections), you can use FMTsesmodel.Greedyreferencebuild() to make the simulation proper, and obtain a spatially-explicit schedule based on the spatially-referenced schedule.\nFMTsesmodel.Greedyreferencebuild() needs a the spatially-referenced solution of a FMTlpmodel (or a FMTnssmodel), in the form of a FMTschedule object. This solution describes which development (or strata) get harvested for one period, with which action, and at which surface/area.\nThe FMTschedule from a solutioned FMTlpmodel or FMTnssmodel can be retrieved using their function getsolution(). However, the function will retrieve the solution for one period; we will have to loop around the periods to get the solutions for every period of interest, and to indicate if we want the solution to take into account locked developments.\nFMTsesmodel.Greedyreferencebuild() will build a spatially explicit solution from a spatially-referenced one for a given period. Along with the FMTschedule for the period, the function will need a randomiterations argument which is the maximal number of iterations done by the algorithm before it stops when no increase in the objective function value (maximization) or decrease in the primal infeasibility value was found. This is because the simulation consist of iterations where the model will try to place cutblocks in space according to the spatially-referenced schedule in order to increase the objective function of the model (e.g., volume harvested) while respecting the linear and spatial constraints that was given (whose deviation from is represented by the primal infeasibility value).\nA last input is a seed number that will be used to generate random numbers used for creating the cut blocks at each iteration. This system of seed allows FMT to use random numbers that are \u0026ldquo;replicable\u0026rdquo;; that means, if you keep the same seed, FMT will get the same random numbers, and will do the exact same simulations.\nHere is a representation of how the simulation algorithm functions in practice :\n  In R, the code to use FMTsesmodel.Greedyreferencebuild() will look like this :\nlibrary(FMT) # Loads FMT into R\rif (new(FMTversion)$hasfeature(\u0026quot;OSI\u0026quot;)) # Checks if FMT has been compiled with OSI by creating a new FMTversion object, and using the function hasfeature().\r{\r# We read and solve a FMTlpmodel; see the spatially referenced optimization for more details\rnewparser \u0026lt;- new(FMTmodelparser)\rmodelslist \u0026lt;- newmodelparser$readproject(\u0026quot;Models/TWD_land/TWD_land.pri\u0026quot;, c(\u0026quot;Spatial\u0026quot;), TRUE, TRUE, TRUE)\rsolverinterface \u0026lt;- list(CLP=1,MOSEK=2,CPLEX=3,GUROBI=4)\rlpmodel \u0026lt;- new(FMTlpmodel,modelslist[[1]],solverinterface$MOSEK)\remptyschedule \u0026lt;- new(FMTschedule)\rfor (period in 1:10)\r{\rprint(lpmodel$buildperiod(emptyschedule,FALSE,1)$str())\r}\rallmodelconstraints \u0026lt;- lpmodel$getconstraints()\rmodelobjective \u0026lt;- allmodelconstraints[[1]]\rmodelconstraints \u0026lt;- allmodelconstraints[2:length(allmodelconstraints)]\rfor (constraint in modelconstraints)\r{\rprint(lpmodel$setconstraint(constraint)$str())\r}\rprint(lpmodel$setobjective(modelobjective)$str())\r# Here, by testing if the model is able to be solved, we solve the model as initialsolve() does both.\rif (lpmodel$initialsolve())\r{\r# We create a new spatialy explicit simulation model, based on the content of lpmodel\rsimulationmodel \u0026lt;- new(FMTsesmodel, lpmodel)\r# We make sure that the transition in the model are single output, and we modify them if needed.\rsingletransition \u0026lt;- list()\rfor (transition in simulationmodel$gettransitions())\r{\r# The +1 here is made to adapt to the fact that FMT have a C++ code that works in base 0; while R works in base 1 (1 is the first index number of a list)\rsingletransitions[[length(singletransitions) + 1]] \u0026lt;- transition$single()\r}\rsimulationmodel$settransitions(singletransitions)\r# We prepare a parser to read the initial forest map\rareaparser \u0026lt;- new(FMTareaparser)\r# We define where the raster with the information about the initial age of all forests.\rrasterslocation \u0026lt;- \u0026quot;../Models/TWD_land/rasters\u0026quot;\rageraster \u0026lt;- file.path(rasterlocation,\u0026quot;AGE.tif\u0026quot;)\r# We read the different rasters that contain the initial \u0026quot;themes\u0026quot; (attribute) of the different forests\r# by doing a loop on all of the themes defined in the model, and by putting them in a list\rthemesrasters \u0026lt;- list()\rthemeid \u0026lt;- 1\rfor (theme in simulationmodel$gethemes())\r{\rthemesrasters[[length(themesrasters) + 1]] \u0026lt;- file.path(rasterslocation, paste(\u0026quot;THEME\u0026quot;, paste0(themeID), \u0026quot;.tif\u0026quot;, sep = \u0026quot;\u0026quot;))\rthemeid \u0026lt;- themeid + 1\r}\r# Now that we have all of the rasters, we create a FMTforest object by reading all of theme, which will contain the initial forest data.\rinitialforestmap \u0026lt;- areaparser$readrasters(simulationmodel$getthemes(), unlist(themerasters), ageraster, 1, 0.0001, \u0026quot;\u0026quot;)\r# We give the initial forest data to the spatially explicit model\rsimulationmodel$setinitialmapping(initialforestmap)\r# Now, we find the spatially explicit solution for each period based on the solution of the lpmodel for this period.\r# We will stop the search of the algorithm once that it will have made no progress in increasing the optimization function\r# or reduced the primal infeasibility since 10 iterations.\rfor (period in 1:10)\r{\rprint(simulationmodel$greedyreferencebuild(lpmodel$getsolution(period,FALSE), 10, 0, 0.0001))\r}\r}\r} else { # if the model hasn't been compiled with OSI, we display an error.\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r}\r The equivalent in Python is :\nimport sys\rfrom FMT import Models\rfrom FMT import Parser\rfrom FMT import Version\rif __name__ == \u0026quot;__main__\u0026quot;:\rif Version.FMTversion().hasfeature(\u0026quot;OSI\u0026quot;):\r# We read and solve a FMTlpmodel; see the spatially referenced optimization for more details\rnewmodelparser= Parser.FMTmodelparser()\rpath = \u0026quot;Models/TWD_Land/TWD_Land.pri\u0026quot;\rscenarios = [\u0026quot;Spatial\u0026quot;]\rmodelslist = newmodelparser.readproject(path, scenarios)\rlpmodel = Models.FMTlpmodel(modelslist[0], Models.FMTsolverinterface.CLP)\rfor period in range(1, 11):\rprint(lpmodel.buildperiod())\rconstraints = lpmodel.getconstraints()\robjective = constraints.pop(0)\rfor constraint in constraints:\rlpmodel.setconstraint(constraint)\rlpmodel.setobjective(objective)\r# Here, by testing if the model is able to be solved, we solve the model as initialsolve() does both.\rif lpmodel.initialsolve():\r# We create a new spatialy explicit simulation model, based on the content of lpmodel\rsimulationmodel = Models.FMTsesmodel(lpmodel)\r# We make sure that the transition in the model are single output, and we modify them if needed.\rsingletransitions = []\rfor transition in simulationmodel.gettransitions():\rsingletransitions.append(transition.single())\rsimulationmodel.settransitions(singletransitions)\r# We prepare a parser to read the initial forest map\rareaparser = Parser.FMTareaparser()\r# We define where the raster with the information about the initial age of all forests.\rrasterslocation = \u0026quot;../Models/TWD_land/rasters/\u0026quot;\rageraster = os.path.join(rasterslocation, \u0026quot;AGE.tif\u0026quot;)\r# We read the different rasters that contain the initial \u0026quot;themes\u0026quot; (attribute) of the different forests\r# by doing a loop on all of the themes defined in the model, and by putting them in a list\rthemesrasters = []\rthemeid = 1\rfor theme in simulationmodel.getthemes():\rthemesrasters.append(os.path.join(rasterslocation, \u0026quot;THEME\u0026quot; + str(themeid) + \u0026quot;.tif\u0026quot;))\rthemeid += 1\r# Now that we have all of the rasters, we create a FMTforest object by reading all of theme, which will contain the initial forest data.\rinitialforestmap = areaparser.readrasters(simulationmodel.getthemes(), themesrasters, ageraster, 1, 0.0001)\r# We give the initial forest data to the spatially explicit model\rsimulationmodel.setinitialmapping(initialforestmap)\r# Now, we find the spatially explicit solution for each period based on the solution of the lpmodel for this period.\r# We will stop the search of the algorithm once that it will have made no progress in increasing the optimization function\r# or reduced the primal infeasibility since 10 iterations.\rfor period in range(1, 11):\rprint(simulationmodel.greedyreferencebuild(lpmodel.getsolution(period), 10))\relse:\rprint(\u0026quot;FMT needs to be compiled with OSI\u0026quot;)\r The output of both codes should be the following. There is a lot to process, but we will look at it more precisely at the next section :\nReading D:/TempCode/FMT/FMT/Examples/Models/TWD_land/TWD_Land.pri FMT 0.9.1, build: Oct 22 2021 11:52:53\rFri Feb 18 12:44:56 2022\rReading scenario Spatial\rFMTexc(41)Ignoring: YBM_RTM_MEH at line 44 FMTsection(6)Yield\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rDone reading Fri Feb 18 12:44:56 2022\rColumns: 69 Rows: 34 Vertices: 62 Edges: 69 Transfer Rows: 34 Output Rows: 0 Output Columns: 0\rColumns: 173 Rows: 86 Vertices: 126 Edges: 173 Transfer Rows: 86 Output Rows: 0 Output Columns: 0\rColumns: 320 Rows: 156 Vertices: 208 Edges: 320 Transfer Rows: 156 Output Rows: 0 Output Columns: 0\rColumns: 510 Rows: 244 Vertices: 308 Edges: 510 Transfer Rows: 244 Output Rows: 0 Output Columns: 0\rColumns: 730 Rows: 350 Vertices: 426 Edges: 730 Transfer Rows: 350 Output Rows: 0 Output Columns: 0\rColumns: 986 Rows: 474 Vertices: 562 Edges: 986 Transfer Rows: 474 Output Rows: 0 Output Columns: 0\rColumns: 1278 Rows: 616 Vertices: 716 Edges: 1278 Transfer Rows: 616 Output Rows: 0 Output Columns: 0\rColumns: 1606 Rows: 776 Vertices: 888 Edges: 1606 Transfer Rows: 776 Output Rows: 0 Output Columns: 0\rColumns: 1992 Rows: 964 Vertices: 1088 Edges: 1992 Transfer Rows: 964 Output Rows: 0 Output Columns: 0\rColumns: 2436 Rows: 1180 Vertices: 1316 Edges: 2436 Transfer Rows: 1180 Output Rows: 0 Output Columns: 0\rCoin0506I Presolve 76 (-1143) rows, 226 (-2211) columns and 898 (-5379) elements\rClp0035I 0 Primal 100 Dual 842632.63 Complementarity 842579 - 0 fixed, rank 76\rClp0035I 1 Primal 225.4735 Dual 307283.38 Complementarity 318751.96 - 0 fixed, rank 76\rClp0035I 2 Primal 7266.7264 Dual 146511.3 Complementarity 174120.63 - 0 fixed, rank 76\rClp0035I 3 Primal 35053.074 Dual 105622.03 Complementarity 73089.174 - 0 fixed, rank 76\rClp0035I 4 Primal 38320.846 Dual 70235.705 Complementarity 33405.695 - 0 fixed, rank 76\rClp0035I 5 Primal 44403.19 Dual 55792.68 Complementarity 11676.178 - 0 fixed, rank 76\rClp0035I 6 Primal 46801.335 Dual 50712.255 Complementarity 3964.085 - 0 fixed, rank 76\rClp0035I 7 Primal 47534.239 Dual 48865.81 Complementarity 1331.5805 - 0 fixed, rank 76\rClp0035I 8 Primal 47849.045 Dual 48152.188 Complementarity 303.14539 - 0 fixed, rank 76\rClp0035I 9 Primal 47959.375 Dual 48049.655 Complementarity 90.456075 - 0 fixed, rank 76\rClp0035I 10 Primal 47999.651 Dual 48009.843 Complementarity 10.204147 - 0 fixed, rank 76\rClp0035I 11 Primal 47998.773 Dual 48000.252 Complementarity 1.4873248 - 0 fixed, rank 76\rClp0035I 12 Primal 47999.994 Dual 48000.002 Complementarity 0.0085757189 - 0 fixed, rank 76\rClp0035I 13 Primal 48000 Dual 48000 Complementarity 0.00011127406 - 0 fixed, rank 70\rClp0035I 14 Primal 48000 Dual 48000 Complementarity 1.102542e-06 - 0 fixed, rank 63\rClp0035I 15 Primal 48000 Dual 48000.074 Complementarity 8.4407744e-09 - 20 fixed, rank 68\rClp0035I 16 Primal 48000 Dual 48000 Complementarity 6.8286544e-11 - 20 fixed, rank 65\rClp0042I Optimal\rClp0046I At end primal/dual infeasibilities 0.00015298276/0.10009623, complementarity gap 4.668539e-06, objective 48000\rClp0006I 0 Obj 48000 Dual inf 0.015282 (8)\rClp0006I 152 Obj 48000\rClp0000I Optimal - objective value 48000\rClp0006I 0 Obj 48000\rClp0000I Optimal - objective value 48000\rClp0006I 0 Obj 48000\rClp0000I Optimal - objective value 48000\rCoin0511I After Postsolve, objective 48000, infeasibilities - dual 0 (0), primal 0 (0)\rClp0032I Optimal objective 48000 - 16 iterations time 0.022, Presolve 0.01\rIteration 0 Primal Inf(0.000000) Obj(40475.320000)\rIteration 10 Primal Inf(0.000000) Obj(44085.320000)\rStalled after 16 iterations Skipping\r{'ACARIBOU': 0.981677543988014, 'COUPETOTALE': 0.9817026645791909, 'Objective': 42453.599999999984, 'Primalinfeasibility': 0.0, 'Total': 0.9816850800303768}\rIteration 0 Primal Inf(2310.400000) Obj(40143.200000)\rIteration 10 Primal Inf(216.600000) Obj(42237.000000)\rIteration 20 Primal Inf(0.000000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 1.0278470194296387, 'COUPETOTALE': 0.9116104392588846, 'Objective': 42453.599999999984, 'PLANTATION': 0.927291117344956, 'Primalinfeasibility': 1.4551915228366852e-11, 'Total': 0.9264994202031354}\rIteration 0 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 10 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 20 Primal Inf(635.360000) Obj(42453.600000)\rSolution stuck after 27 iterations Skipping\r{'ACARIBOU': 0.8973831819756647, 'COUPETOTALE': 0.9033560325101042, 'Objective': 42453.599999999984, 'PLANTATION': 0.911737449703183, 'Primalinfeasibility': 635.3600000000297, 'Total': 0.9025186555019942}\rIteration 0 Primal Inf(8779.520000) Obj(42453.600000)\rIteration 10 Primal Inf(8779.520000) Obj(42453.600000)\rIteration 20 Primal Inf(808.640000) Obj(42453.600000)\rSolution stuck after 29 iterations Skipping\r{'ACARIBOU': 0.8771528754492212, 'COUPETOTALE': 0.889988896215573, 'Objective': 42453.599999999984, 'PLANTATION': 0.8765659747164727, 'Primalinfeasibility': 808.6400000000212, 'Total': 0.8822416209150494}\rIteration 0 Primal Inf(6931.200000) Obj(42453.600000)\rIteration 10 Primal Inf(6931.200000) Obj(42453.600000)\rIteration 20 Primal Inf(1111.880000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 0.8952525436304627, 'COUPETOTALE': 0.88445, 'Objective': 42453.599999999984, 'PLANTATION': 0.9411700993142432, 'Primalinfeasibility': 1111.8800000000338, 'Total': 0.9032996680762417}\rIteration 0 Primal Inf(9342.680000) Obj(42453.600000)\rIteration 10 Primal Inf(3638.880000) Obj(42453.600000)\rIteration 20 Primal Inf(3638.880000) Obj(42453.600000)\rIteration 30 Primal Inf(3638.880000) Obj(42453.600000)\rSolution stuck after 35 iterations Skipping\r{'ACARIBOU': 968.4932690882329, 'COUPETOTALE': 0.9397466289394396, 'Objective': 42453.599999999984, 'PLANTATION': 2367.8747068875177, 'Primalinfeasibility': 3638.8800000000047, 'Total': 1.0649491134961293}\rIteration 0 Primal Inf(16606.000000) Obj(30309.560000)\rStalled after 9 iterations Skipping\r{'ACARIBOU': 1.3474601235578203, 'COUPETOTALE': 0.9825519488602954, 'Objective': 32937.64000000001, 'PLANTATION': 1.0022853728788734, 'Primalinfeasibility': 13977.919999999998, 'Total': 1.0087375080393326}\rIteration 0 Primal Inf(119576.200000) Obj(32937.640000)\rIteration 10 Primal Inf(65859.400000) Obj(32937.640000)\rIteration 20 Primal Inf(39247.920000) Obj(32937.640000)\rSolution stuck after 28 iterations Skipping\r{'ACARIBOU': 1054.0980891170655, 'COUPETOTALE': 0.845845565618348, 'Objective': 32937.64000000001, 'PLANTATION': 0.9266686936638757, 'Primalinfeasibility': 39247.9200000001, 'Total': 0.8969889215263215}\rIteration 0 Primal Inf(58611.960000) Obj(27522.640000)\rStalled after 6 iterations Skipping\r{'ACARIBOU': 536.8311084909311, 'COUPETOTALE': 0.4341194959208162, 'Objective': 27667.040000000005, 'PLANTATION': 0.9541653732993195, 'Primalinfeasibility': 58467.560000000114, 'Total': 0.7846327502399465}\rIteration 0 Primal Inf(79145.640000) Obj(26208.600000)\rIteration 10 Primal Inf(77340.640000) Obj(27667.040000)\rStalled after 14 iterations Skipping\r{'ACARIBOU': 10491.125109295706, 'COUPETOTALE': 0.3982872281191633, 'Objective': 27667.040000000005, 'PLANTATION': 1.0028031096555103, 'Primalinfeasibility': 77340.64000000012, 'Total': 0.8163283360740083}\r Analysing the outputs of FMTsesmodel.Greedyreferencebuild() FMTsesmodel.Greedyreferencebuild() returns information on the best solution that have been found; which means the best spatial placement of cutblocks that the algorithm was capable of finding by optimizing the objective function, while respecting the linear and spatial constraints that were given by the user.\nIn particular, FMTsesmodel.Greedyreferencebuild() indicates 4 important information :\n   Word Description     Objective Value of the objective function of the spatially explicit solution.   Primalinfeasibilities Primal infeasibility value of the spatially explicit solution, relative to the constraints that were given. A value close to 0 means that the solution is 100% feasible according to the linear and spatial constraints.   Total Total proportion of the area of the spatially referenced schedule passed as input that has been spatialized successfully by the algorithm.   Actionname x Proportion of the area spatialized of a given action x of the original spatially referenced solution passed to the function.    Now, let\u0026rsquo;s look at the output of the previous section to try and understand what happened.\nFirst, we see the same usual outputs that indicates that FMT reads, and then solves the model using the CLP solver :\nReading D:/TempCode/FMT/FMT/Examples/Models/TWD_land/TWD_Land.pri FMT 0.9.1, build: Oct 22 2021 11:52:53\rFri Feb 18 12:44:56 2022\rReading scenario Spatial\rFMTexc(41)Ignoring: YBM_RTM_MEH at line 44 FMTsection(6)Yield\rFMTexc(39)Undefined _death action: _DEATH FMTsection(4)Action\rDone reading Fri Feb 18 12:44:56 2022\rColumns: 69 Rows: 34 Vertices: 62 Edges: 69 Transfer Rows: 34 Output Rows: 0 Output Columns: 0\rColumns: 173 Rows: 86 Vertices: 126 Edges: 173 Transfer Rows: 86 Output Rows: 0 Output Columns: 0\rColumns: 320 Rows: 156 Vertices: 208 Edges: 320 Transfer Rows: 156 Output Rows: 0 Output Columns: 0\rColumns: 510 Rows: 244 Vertices: 308 Edges: 510 Transfer Rows: 244 Output Rows: 0 Output Columns: 0\rColumns: 730 Rows: 350 Vertices: 426 Edges: 730 Transfer Rows: 350 Output Rows: 0 Output Columns: 0\rColumns: 986 Rows: 474 Vertices: 562 Edges: 986 Transfer Rows: 474 Output Rows: 0 Output Columns: 0\rColumns: 1278 Rows: 616 Vertices: 716 Edges: 1278 Transfer Rows: 616 Output Rows: 0 Output Columns: 0\rColumns: 1606 Rows: 776 Vertices: 888 Edges: 1606 Transfer Rows: 776 Output Rows: 0 Output Columns: 0\rColumns: 1992 Rows: 964 Vertices: 1088 Edges: 1992 Transfer Rows: 964 Output Rows: 0 Output Columns: 0\rColumns: 2436 Rows: 1180 Vertices: 1316 Edges: 2436 Transfer Rows: 1180 Output Rows: 0 Output Columns: 0\rCoin0506I Presolve 76 (-1143) rows, 226 (-2211) columns and 898 (-5379) elements\rClp0035I 0 Primal 100 Dual 842632.63 Complementarity 842579 - 0 fixed, rank 76\rClp0035I 1 Primal 225.4735 Dual 307283.38 Complementarity 318751.96 - 0 fixed, rank 76\rClp0035I 2 Primal 7266.7264 Dual 146511.3 Complementarity 174120.63 - 0 fixed, rank 76\rClp0035I 3 Primal 35053.074 Dual 105622.03 Complementarity 73089.174 - 0 fixed, rank 76\rClp0035I 4 Primal 38320.846 Dual 70235.705 Complementarity 33405.695 - 0 fixed, rank 76\rClp0035I 5 Primal 44403.19 Dual 55792.68 Complementarity 11676.178 - 0 fixed, rank 76\rClp0035I 6 Primal 46801.335 Dual 50712.255 Complementarity 3964.085 - 0 fixed, rank 76\rClp0035I 7 Primal 47534.239 Dual 48865.81 Complementarity 1331.5805 - 0 fixed, rank 76\rClp0035I 8 Primal 47849.045 Dual 48152.188 Complementarity 303.14539 - 0 fixed, rank 76\rClp0035I 9 Primal 47959.375 Dual 48049.655 Complementarity 90.456075 - 0 fixed, rank 76\rClp0035I 10 Primal 47999.651 Dual 48009.843 Complementarity 10.204147 - 0 fixed, rank 76\rClp0035I 11 Primal 47998.773 Dual 48000.252 Complementarity 1.4873248 - 0 fixed, rank 76\rClp0035I 12 Primal 47999.994 Dual 48000.002 Complementarity 0.0085757189 - 0 fixed, rank 76\rClp0035I 13 Primal 48000 Dual 48000 Complementarity 0.00011127406 - 0 fixed, rank 70\rClp0035I 14 Primal 48000 Dual 48000 Complementarity 1.102542e-06 - 0 fixed, rank 63\rClp0035I 15 Primal 48000 Dual 48000.074 Complementarity 8.4407744e-09 - 20 fixed, rank 68\rClp0035I 16 Primal 48000 Dual 48000 Complementarity 6.8286544e-11 - 20 fixed, rank 65\rClp0042I Optimal\rClp0046I At end primal/dual infeasibilities 0.00015298276/0.10009623, complementarity gap 4.668539e-06, objective 48000\rClp0006I 0 Obj 48000 Dual inf 0.015282 (8)\rClp0006I 152 Obj 48000\rClp0000I Optimal - objective value 48000\rClp0006I 0 Obj 48000\rClp0000I Optimal - objective value 48000\rClp0006I 0 Obj 48000\rClp0000I Optimal - objective value 48000\rCoin0511I After Postsolve, objective 48000, infeasibilities - dual 0 (0), primal 0 (0)\rClp0032I Optimal objective 48000 - 16 iterations time 0.022, Presolve 0.01\r Then, we can see the lines that corresponds to the simulations of the function FMTsesmodel.Greedyreferencebuild() :\nIteration 0 Primal Inf(0.000000) Obj(40475.320000)\rIteration 10 Primal Inf(0.000000) Obj(44085.320000)\rStalled after 16 iterations Skipping\r{'ACARIBOU': 0.981677543988014, 'COUPETOTALE': 0.9817026645791909, 'Objective': 42453.599999999984, 'Primalinfeasibility': 0.0, 'Total': 0.9816850800303768}\rIteration 0 Primal Inf(2310.400000) Obj(40143.200000)\rIteration 10 Primal Inf(216.600000) Obj(42237.000000)\rIteration 20 Primal Inf(0.000000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 1.0278470194296387, 'COUPETOTALE': 0.9116104392588846, 'Objective': 42453.599999999984, 'PLANTATION': 0.927291117344956, 'Primalinfeasibility': 1.4551915228366852e-11, 'Total': 0.9264994202031354}\rIteration 0 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 10 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 20 Primal Inf(635.360000) Obj(42453.600000)\rSolution stuck after 27 iterations Skipping\r{'ACARIBOU': 0.8973831819756647, 'COUPETOTALE': 0.9033560325101042, 'Objective': 42453.599999999984, 'PLANTATION': 0.911737449703183, 'Primalinfeasibility': 635.3600000000297, 'Total': 0.9025186555019942}\rIteration 0 Primal Inf(8779.520000) Obj(42453.600000)\rIteration 10 Primal Inf(8779.520000) Obj(42453.600000)\rIteration 20 Primal Inf(808.640000) Obj(42453.600000)\rSolution stuck after 29 iterations Skipping\r{'ACARIBOU': 0.8771528754492212, 'COUPETOTALE': 0.889988896215573, 'Objective': 42453.599999999984, 'PLANTATION': 0.8765659747164727, 'Primalinfeasibility': 808.6400000000212, 'Total': 0.8822416209150494}\rIteration 0 Primal Inf(6931.200000) Obj(42453.600000)\rIteration 10 Primal Inf(6931.200000) Obj(42453.600000)\rIteration 20 Primal Inf(1111.880000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 0.8952525436304627, 'COUPETOTALE': 0.88445, 'Objective': 42453.599999999984, 'PLANTATION': 0.9411700993142432, 'Primalinfeasibility': 1111.8800000000338, 'Total': 0.9032996680762417}\rIteration 0 Primal Inf(9342.680000) Obj(42453.600000)\rIteration 10 Primal Inf(3638.880000) Obj(42453.600000)\rIteration 20 Primal Inf(3638.880000) Obj(42453.600000)\rIteration 30 Primal Inf(3638.880000) Obj(42453.600000)\rSolution stuck after 35 iterations Skipping\r{'ACARIBOU': 968.4932690882329, 'COUPETOTALE': 0.9397466289394396, 'Objective': 42453.599999999984, 'PLANTATION': 2367.8747068875177, 'Primalinfeasibility': 3638.8800000000047, 'Total': 1.0649491134961293}\rIteration 0 Primal Inf(16606.000000) Obj(30309.560000)\rStalled after 9 iterations Skipping\r{'ACARIBOU': 1.3474601235578203, 'COUPETOTALE': 0.9825519488602954, 'Objective': 32937.64000000001, 'PLANTATION': 1.0022853728788734, 'Primalinfeasibility': 13977.919999999998, 'Total': 1.0087375080393326}\rIteration 0 Primal Inf(119576.200000) Obj(32937.640000)\rIteration 10 Primal Inf(65859.400000) Obj(32937.640000)\rIteration 20 Primal Inf(39247.920000) Obj(32937.640000)\rSolution stuck after 28 iterations Skipping\r{'ACARIBOU': 1054.0980891170655, 'COUPETOTALE': 0.845845565618348, 'Objective': 32937.64000000001, 'PLANTATION': 0.9266686936638757, 'Primalinfeasibility': 39247.9200000001, 'Total': 0.8969889215263215}\rIteration 0 Primal Inf(58611.960000) Obj(27522.640000)\rStalled after 6 iterations Skipping\r{'ACARIBOU': 536.8311084909311, 'COUPETOTALE': 0.4341194959208162, 'Objective': 27667.040000000005, 'PLANTATION': 0.9541653732993195, 'Primalinfeasibility': 58467.560000000114, 'Total': 0.7846327502399465}\rIteration 0 Primal Inf(79145.640000) Obj(26208.600000)\rIteration 10 Primal Inf(77340.640000) Obj(27667.040000)\rStalled after 14 iterations Skipping\r{'ACARIBOU': 10491.125109295706, 'COUPETOTALE': 0.3982872281191633, 'Objective': 27667.040000000005, 'PLANTATION': 1.0028031096555103, 'Primalinfeasibility': 77340.64000000012, 'Total': 0.8163283360740083}\r This first line tells us about the first solution found by the simulation : in this solution, the primal infeasibility value is 0, meaning that the solution is 100% feasible, and that the constraints that we put are always respected. However, we can see that the value of the objective function is lower than the one found by the solving of the spatially referenced model (which was 48000).\nIteration 0 Primal Inf(0.000000) Obj(40475.320000)\r After 10 generated solutions, we can see that the primal infeasibility is still 0, and that the value of the objective function has increased to 448085.32.\nIteration 10 Primal Inf(0.000000) Obj(44085.320000)\r Then, FMT ends the simulations for the first period by telling us why it stopped searching, and the proportion of each actions that it was able to place into space.\nHere, for the first period, FMT stopped searching by indicating that the algorithm stalled. Meanwhile, it was able to spatialize 98% of the ACARIBOU action, and 98% of the COUPETOTALE action.\nStalled after 16 iterations Skipping\r{'ACARIBOU': 0.981677543988014, 'COUPETOTALE': 0.9817026645791909, 'Objective': 42453.599999999984, 'Primalinfeasibility': 0.0, 'Total': 0.9816850800303768}\r The process then repeats for the 9 other periods. Each time, FMT starts with a first iteration of placing the actions in space while trying to respect the constraints. Then, the algorithm ends when it either get stalled, or stuck, meaning that it can\u0026rsquo;t improve the solution or reduce the primal infeasibility anymore. It then displays the amount of actions that it was able to place in space.\nNote that stalled and stuck have two different meaning :\n Stalled means that the algorithm have generated the same exact solutions (the same placement of the cuts in space) as its 3 last iterations, implying that it cannot generate any new solution. This can happen when the constraints makes it so that the number of potential solutions are limited, which means that the algorithm will quickly have tried them all. Stuck means that the algorithm was able to generate different solutions; but that all of these new solutions have an objective function value that is not higher than the previous ones, or that these new solutions cannot reduce the primal infeasibility. After a number of iterations corresponding to the randomiterations arguments provided to FMTsesmodel.Greedyreferencebuild() without any improvements, the algorithm will stop.  For the second period, we can see :\nIteration 0 Primal Inf(2310.400000) Obj(40143.200000)\rIteration 10 Primal Inf(216.600000) Obj(42237.000000)\rIteration 20 Primal Inf(0.000000) Obj(42453.600000)\rSolution stuck after 30 iterations Skipping\r{'ACARIBOU': 1.0278470194296387, 'COUPETOTALE': 0.9116104392588846, 'Objective': 42453.599999999984, 'PLANTATION': 0.927291117344956, 'Primalinfeasibility': 1.4551915228366852e-11, 'Total': 0.9264994202031354}\r For the third period, we can see :\nIteration 0 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 10 Primal Inf(2108.240000) Obj(42453.600000)\rIteration 20 Primal Inf(635.360000) Obj(42453.600000)\rSolution stuck after 27 iterations Skipping\r{'ACARIBOU': 0.8973831819756647, 'COUPETOTALE': 0.9033560325101042, 'Objective': 42453.599999999984, 'PLANTATION': 0.911737449703183, 'Primalinfeasibility': 635.3600000000297, 'Total': 0.9025186555019942}\r And so on until the 10th period.\n You should now know enough to start using FMT by yourself. If you have any remaining questions, please contact Guillaume Cyr or Bruno Forest from the BFEC. You can also install FMT on your computer by following the Downloading and installing section.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"793eb7f10f8d83f2a8f6adcc3e722198","permalink":"/docs/basics/spatially_explicit_simulation/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/docs/basics/spatially_explicit_simulation/","section":"docs","summary":"A quick reminder of the meaning of \u0026ldquo;spatially explicit\u0026rdquo; We can distinguish 3 ways that space can be taken into account in a model :\n In a non-spatial model or spatially implicit model, entities (e.","tags":null,"title":"Spatially explicit simulation","type":"book"}]